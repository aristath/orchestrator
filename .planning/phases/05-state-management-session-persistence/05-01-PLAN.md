---
phase: 05-state-management-session-persistence
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/persistence/store.go
  - internal/persistence/schema.go
  - internal/persistence/tasks.go
  - internal/persistence/store_test.go
autonomous: true

must_haves:
  truths:
    - "Task state (ID, name, status, result, error, dependencies) round-trips through SQLite without data loss"
    - "SaveTask is idempotent -- calling twice with same task ID updates rather than errors"
    - "UpdateTaskStatus persists status transitions (Pending->Running->Completed) and survives DB close/reopen"
    - "ListTasks returns all persisted tasks with correct statuses and dependency lists"
    - "Foreign keys are enforced -- inserting a dependency on a non-existent task fails"
  artifacts:
    - path: "internal/persistence/store.go"
      provides: "Store interface and SQLiteStore constructor with WAL mode"
      exports: ["Store", "SQLiteStore", "NewSQLiteStore", "ConversationTurn"]
    - path: "internal/persistence/schema.go"
      provides: "Schema initialization for tasks, task_dependencies, sessions, conversation_history tables"
      contains: "CREATE TABLE IF NOT EXISTS tasks"
    - path: "internal/persistence/tasks.go"
      provides: "SaveTask, GetTask, UpdateTaskStatus, ListTasks methods on SQLiteStore"
      contains: "ON CONFLICT"
    - path: "internal/persistence/store_test.go"
      provides: "Tests for task persistence using in-memory SQLite"
      contains: "testDB"
  key_links:
    - from: "internal/persistence/tasks.go"
      to: "internal/scheduler/task.go"
      via: "imports scheduler.Task, scheduler.TaskStatus, scheduler.FailureMode"
      pattern: "scheduler\\.Task"
    - from: "internal/persistence/store.go"
      to: "database/sql"
      via: "sql.Open with modernc.org/sqlite driver"
      pattern: "sql\\.Open"
---

<objective>
Create the persistence layer foundation: Store interface, SQLite schema, and task DAG persistence methods.

Purpose: Provides the database layer that all subsequent persistence work builds on. Task state persistence is the core requirement (STATE-01) -- the DAG structure, task statuses, and results must survive crashes.

Output: `internal/persistence/` package with Store interface, SQLiteStore implementation, schema init, and fully tested task CRUD operations.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-state-management-session-persistence/05-RESEARCH.md
@internal/scheduler/task.go
@internal/backend/types.go
@internal/backend/backend.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store interface, SQLiteStore constructor, and schema initialization</name>
  <files>
    internal/persistence/store.go
    internal/persistence/schema.go
  </files>
  <action>
Create the `internal/persistence/` package.

**store.go** -- Define the Store interface and SQLiteStore struct:

```go
type ConversationTurn struct {
    Role      string    // "user" or "assistant"
    Content   string
    Timestamp time.Time
}

type Store interface {
    // Task DAG operations
    SaveTask(ctx context.Context, task *scheduler.Task) error
    GetTask(ctx context.Context, taskID string) (*scheduler.Task, error)
    UpdateTaskStatus(ctx context.Context, taskID string, status scheduler.TaskStatus, result string, taskErr error) error
    ListTasks(ctx context.Context) ([]*scheduler.Task, error)

    // Session operations
    SaveSession(ctx context.Context, taskID, sessionID, backendType string) error
    GetSession(ctx context.Context, taskID string) (sessionID string, backendType string, err error)

    // Conversation history
    SaveMessage(ctx context.Context, taskID, role, content string) error
    GetHistory(ctx context.Context, taskID string) ([]ConversationTurn, error)

    // Lifecycle
    Close() error
}
```

SQLiteStore constructor `NewSQLiteStore(ctx context.Context, dbPath string)` that:
1. Creates parent directories with `os.MkdirAll`
2. Opens SQLite with connection string: `file:{path}?_foreign_keys=ON&_journal_mode=WAL&_busy_timeout=5000&_synchronous=NORMAL`
3. Sets `db.SetMaxOpenConns(1)` for single-writer safety
4. Calls `initSchema(ctx)`
5. Returns `*SQLiteStore` or error

Also support a `NewMemoryStore(ctx context.Context)` constructor for tests that uses `:memory:?_foreign_keys=ON` -- this avoids WAL mode since in-memory DBs don't need it.

Import the SQLite driver with blank import: `_ "modernc.org/sqlite"`

**schema.go** -- `initSchema` method that creates all four tables using `CREATE TABLE IF NOT EXISTS`:
- `tasks` table: id TEXT PK, name TEXT NOT NULL, agent_role TEXT NOT NULL, prompt TEXT NOT NULL, writes_files TEXT (comma-separated), status INTEGER NOT NULL, failure_mode INTEGER NOT NULL, result TEXT, error TEXT, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
- `task_dependencies` table: task_id TEXT NOT NULL, depends_on_id TEXT NOT NULL, composite PK (task_id, depends_on_id), foreign keys to tasks(id) ON DELETE CASCADE, index on task_id
- `sessions` table: task_id TEXT PK, session_id TEXT NOT NULL, backend_type TEXT NOT NULL, created_at DATETIME DEFAULT CURRENT_TIMESTAMP, foreign key to tasks(id) ON DELETE CASCADE
- `conversation_history` table: id INTEGER PK AUTOINCREMENT, task_id TEXT NOT NULL, role TEXT NOT NULL, content TEXT NOT NULL, timestamp DATETIME DEFAULT CURRENT_TIMESTAMP, foreign key to tasks(id) ON DELETE CASCADE, index on (task_id, timestamp)

Execute all DDL in a single `ExecContext` call (SQLite supports multiple statements).

Run `go get modernc.org/sqlite` and `go get github.com/adrg/xdg` to add dependencies.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go build ./internal/persistence/` -- must compile without errors.
  </verify>
  <done>Store interface defined with all methods. SQLiteStore opens SQLite with WAL mode, foreign keys, and busy_timeout. Schema creates all four tables. Package compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Task DAG persistence methods and tests</name>
  <files>
    internal/persistence/tasks.go
    internal/persistence/store_test.go
  </files>
  <action>
**tasks.go** -- Implement task persistence methods on `*SQLiteStore`:

`SaveTask(ctx, task)`: Use BEGIN IMMEDIATE (via `sql.TxOptions{Isolation: sql.LevelSerializable}`) with deferred rollback pattern. INSERT task with ON CONFLICT(id) DO UPDATE for idempotency (update status, result, error, updated_at on conflict). After upserting task, DELETE existing dependencies for that task_id, then INSERT each dependency. Commit transaction. Convert `task.Error` to string for storage (empty string if nil). Store `task.WritesFiles` as comma-joined string.

`GetTask(ctx, taskID)`: QueryRowContext to load task fields. Split writes_files string back to slice. Load dependencies with separate QueryContext on task_dependencies. Reconstruct `task.Error` with `fmt.Errorf` if error string is non-empty. Return `sql.ErrNoRows` wrapped in a descriptive error if not found.

`UpdateTaskStatus(ctx, taskID, status, result, taskErr)`: BEGIN IMMEDIATE transaction. UPDATE tasks SET status, result, error, updated_at WHERE id. Return error if no rows affected (task not found).

`ListTasks(ctx)`: QueryContext all tasks. For each, load dependencies with a second query. Return slice of `*scheduler.Task`. Use a 5-second timeout context derived from the parent context for all queries.

**store_test.go** -- Tests using in-memory database via `NewMemoryStore`:

Create `testStore(t)` helper that calls `NewMemoryStore`, registers `t.Cleanup(store.Close)`, returns store.

Tests:
1. `TestSaveAndGetTask` -- save a task with dependencies, get it back, verify all fields match including DependsOn slice
2. `TestSaveTaskIdempotent` -- save task, update status to Completed, save again, verify status is Completed (not reset to Pending)
3. `TestUpdateTaskStatus` -- save task as Pending, update to Running, update to Completed with result, verify each transition
4. `TestUpdateTaskStatusNotFound` -- update non-existent task, verify error
5. `TestListTasks` -- save 3 tasks with dependencies, list all, verify count and fields
6. `TestForeignKeyEnforced` -- attempt to insert dependency on non-existent task, verify error (proves foreign keys are ON)
7. `TestTaskErrorPersistence` -- save task, mark failed with error message, get task, verify error string round-trips

Run tests with `-race` flag.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go test -race -v ./internal/persistence/` -- all tests must pass with no race conditions.
  </verify>
  <done>SaveTask upserts with ON CONFLICT. GetTask reconstructs full Task including dependencies. UpdateTaskStatus persists transitions. ListTasks returns all tasks. All 7 tests pass with -race flag. Foreign key enforcement verified.</done>
</task>

</tasks>

<verification>
- `go build ./internal/persistence/` compiles
- `go test -race -v ./internal/persistence/` passes all tests
- `go vet ./internal/persistence/` reports no issues
</verification>

<success_criteria>
- Store interface defined with task, session, and conversation methods
- SQLiteStore opens database with WAL mode, foreign keys, busy_timeout pragmas
- Schema creates 4 tables (tasks, task_dependencies, sessions, conversation_history)
- SaveTask is idempotent via ON CONFLICT DO UPDATE
- All write transactions use BEGIN IMMEDIATE (sql.LevelSerializable)
- 7+ tests pass with -race flag using in-memory database
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-management-session-persistence/05-01-SUMMARY.md`
</output>
