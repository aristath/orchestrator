---
phase: 05-state-management-session-persistence
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/persistence/sessions.go
  - internal/persistence/store_test.go
autonomous: true

must_haves:
  truths:
    - "Session IDs round-trip through SQLite with correct backend type (claude/codex/goose)"
    - "Conversation history is stored per-task and retrieved in chronological order"
    - "Saving a session for the same task_id updates the existing session (upsert)"
    - "Getting a session for a non-existent task returns a clear not-found error"
    - "Conversation history preserves role, content, and ordering across close/reopen"
  artifacts:
    - path: "internal/persistence/sessions.go"
      provides: "SaveSession, GetSession, SaveMessage, GetHistory methods on SQLiteStore"
      contains: "ON CONFLICT"
    - path: "internal/persistence/store_test.go"
      provides: "Tests for session and conversation history persistence"
      contains: "TestSaveAndGetSession"
  key_links:
    - from: "internal/persistence/sessions.go"
      to: "internal/persistence/schema.go"
      via: "operates on sessions and conversation_history tables"
      pattern: "sessions|conversation_history"
    - from: "internal/persistence/sessions.go"
      to: "internal/persistence/store.go"
      via: "implements Store interface methods"
      pattern: "func.*SQLiteStore.*Save(Session|Message)|Get(Session|History)"
---

<objective>
Add session ID and conversation history persistence to the SQLiteStore.

Purpose: Enables multi-turn session continuity across restarts (STATE-04) and conversation history recovery (STATE-02). Each backend type (Claude Code, Codex, Goose) uses different session ID formats -- persisting both session_id and backend_type ensures the correct adapter is used on resume.

Output: `sessions.go` with 4 methods and comprehensive tests extending `store_test.go`.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-state-management-session-persistence/05-RESEARCH.md
@.planning/phases/05-state-management-session-persistence/05-01-SUMMARY.md
@internal/persistence/store.go
@internal/persistence/schema.go
@internal/persistence/tasks.go
@internal/backend/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Session and conversation history persistence methods</name>
  <files>
    internal/persistence/sessions.go
  </files>
  <action>
**sessions.go** -- Implement session and conversation methods on `*SQLiteStore`:

`SaveSession(ctx, taskID, sessionID, backendType)`: Use BEGIN IMMEDIATE transaction with deferred rollback. INSERT INTO sessions with ON CONFLICT(task_id) DO UPDATE SET session_id, backend_type (upsert pattern). This handles both first-save and resume scenarios where session ID may change. Commit transaction.

`GetSession(ctx, taskID)`: QueryRowContext to load session_id and backend_type from sessions WHERE task_id. If `sql.ErrNoRows`, return a wrapped descriptive error like `fmt.Errorf("no session found for task %q: %w", taskID, err)` so callers can check with `errors.Is(err, sql.ErrNoRows)`.

`SaveMessage(ctx, taskID, role, content)`: Use BEGIN IMMEDIATE transaction. INSERT INTO conversation_history (task_id, role, content). No upsert needed -- messages are append-only. Commit transaction.

`GetHistory(ctx, taskID)`: QueryContext to SELECT role, content, timestamp FROM conversation_history WHERE task_id ORDER BY timestamp ASC, id ASC (double sort ensures correct order even with same-second timestamps). Scan each row into `ConversationTurn` struct. Return empty slice (not nil) if no history exists.

All methods use 5-second timeout context derived from parent. All write methods use `sql.TxOptions{Isolation: sql.LevelSerializable}` for BEGIN IMMEDIATE.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go build ./internal/persistence/` -- must compile without errors.
  </verify>
  <done>All four session/conversation methods implemented with BEGIN IMMEDIATE transactions and proper error handling.</done>
</task>

<task type="auto">
  <name>Task 2: Session and conversation history tests</name>
  <files>
    internal/persistence/store_test.go
  </files>
  <action>
Add tests to `store_test.go` (extending the existing test file from Plan 01).

Reuse the existing `testStore(t)` helper.

**Session tests:**
1. `TestSaveAndGetSession` -- save a task first (required by FK), save session with taskID/sessionID/"claude", get session, verify sessionID and backendType match
2. `TestSaveSessionUpsert` -- save session with sessionID "abc", save again with sessionID "def" for same task, get session, verify sessionID is "def" (upsert overwrites)
3. `TestGetSessionNotFound` -- get session for non-existent task, verify error wraps `sql.ErrNoRows`
4. `TestSessionBackendTypes` -- save 3 tasks with sessions: one "claude", one "codex", one "goose". Get each, verify correct backend_type returned.

**Conversation history tests:**
5. `TestSaveAndGetHistory` -- save task, save 3 messages (user, assistant, user), get history, verify 3 turns in correct chronological order with correct roles and content
6. `TestGetHistoryEmpty` -- save task with no messages, get history, verify empty slice (not nil) and no error
7. `TestGetHistoryOrdering` -- save 5 messages rapidly, get history, verify order matches insertion order (tests the id-based tiebreaker for same-timestamp entries)
8. `TestConversationHistoryForeignKey` -- attempt SaveMessage for non-existent task_id, verify foreign key error

Run all tests with `-race` flag.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go test -race -v ./internal/persistence/` -- all tests (from both Plan 01 and Plan 02) must pass.
  </verify>
  <done>8 new tests pass. Session upsert verified. Backend type round-trips correctly for all three backends. Conversation history preserves order. Foreign key enforcement verified. All tests pass with -race.</done>
</task>

</tasks>

<verification>
- `go build ./internal/persistence/` compiles
- `go test -race -v ./internal/persistence/` passes all tests (Plan 01 + Plan 02)
- `go vet ./internal/persistence/` reports no issues
</verification>

<success_criteria>
- SaveSession upserts correctly (same task_id updates session)
- GetSession returns both session_id and backend_type
- SaveMessage appends conversation turns
- GetHistory returns turns in chronological order
- All 15+ tests pass with -race flag (7 from Plan 01 + 8 from Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-management-session-persistence/05-02-SUMMARY.md`
</output>
