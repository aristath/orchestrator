---
phase: 05-state-management-session-persistence
plan: 03
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - internal/orchestrator/runner.go
  - internal/orchestrator/runner_test.go
autonomous: true

must_haves:
  truths:
    - "ParallelRunner checkpoints task status to Store on every state transition (Running, Completed, Failed)"
    - "ParallelRunner saves session ID and backend type after successful task execution"
    - "ParallelRunner saves conversation messages (prompt sent and response received) for each task"
    - "Resume reconstructs DAG from Store, skips completed tasks, and executes only pending/eligible tasks"
    - "Resume restores session IDs so backends can continue conversations"
  artifacts:
    - path: "internal/orchestrator/runner.go"
      provides: "Store integration in ParallelRunner and Resume method"
      contains: "Resume"
    - path: "internal/orchestrator/runner_test.go"
      provides: "Tests for checkpoint and resume behavior"
      contains: "TestResume"
  key_links:
    - from: "internal/orchestrator/runner.go"
      to: "internal/persistence/store.go"
      via: "Store field in ParallelRunnerConfig, called during executeTask"
      pattern: "store\\.UpdateTaskStatus|store\\.SaveSession|store\\.SaveMessage"
    - from: "internal/orchestrator/runner.go"
      to: "internal/scheduler/dag.go"
      via: "Reconstructs DAG from persisted tasks in Resume"
      pattern: "dag\\.AddTask|store\\.ListTasks"
    - from: "internal/orchestrator/runner.go"
      to: "internal/backend/backend.go"
      via: "Reads SessionID() from backend after Send, uses Config.SessionID for resume"
      pattern: "b\\.SessionID\\(\\)|cfg\\.SessionID"
---

<objective>
Wire the persistence Store into ParallelRunner for checkpointing and implement Resume from persisted state.

Purpose: This plan closes the loop on all four STATE requirements. Task state is checkpointed at every transition (STATE-01, STATE-03), session IDs are persisted after each task execution (STATE-04), conversation history is saved (STATE-02), and Resume reconstructs the DAG and skips completed work (STATE-03).

Output: Modified `runner.go` with Store integration and Resume method, plus tests proving crash-resume behavior.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-state-management-session-persistence/05-RESEARCH.md
@.planning/phases/05-state-management-session-persistence/05-01-SUMMARY.md
@.planning/phases/05-state-management-session-persistence/05-02-SUMMARY.md
@internal/orchestrator/runner.go
@internal/orchestrator/runner_test.go
@internal/persistence/store.go
@internal/persistence/tasks.go
@internal/persistence/sessions.go
@internal/scheduler/task.go
@internal/scheduler/dag.go
@internal/backend/backend.go
@internal/backend/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate Store into ParallelRunner for checkpointing</name>
  <files>
    internal/orchestrator/runner.go
  </files>
  <action>
Modify `ParallelRunnerConfig` to add an optional `Store persistence.Store` field (nil disables persistence, same pattern as EventBus).

Add a `checkpoint` helper method on `*ParallelRunner` that wraps store calls with nil-check:
```go
func (r *ParallelRunner) checkpoint(fn func(persistence.Store) error) {
    if r.config.Store != nil {
        if err := fn(r.config.Store); err != nil {
            log.Printf("WARNING: checkpoint failed: %v", err)
        }
    }
}
```

Modify `executeTask` to add persistence at these points:

1. **After MarkRunning**: Checkpoint task status to Running.
   ```go
   r.checkpoint(func(s persistence.Store) error {
       return s.UpdateTaskStatus(ctx, task.ID, scheduler.TaskRunning, "", nil)
   })
   ```

2. **After successful b.Send**: Save conversation message (prompt + response), save session ID and backend type, then checkpoint Completed status.
   ```go
   r.checkpoint(func(s persistence.Store) error {
       // Save the prompt we sent
       if err := s.SaveMessage(ctx, task.ID, "user", task.Prompt); err != nil {
           return err
       }
       // Save the response we received
       if err := s.SaveMessage(ctx, task.ID, "assistant", resp.Content); err != nil {
           return err
       }
       // Save session for resume capability
       if err := s.SaveSession(ctx, task.ID, b.SessionID(), backendType(task, r.config)); err != nil {
           return err
       }
       return s.UpdateTaskStatus(ctx, task.ID, scheduler.TaskCompleted, resp.Content, nil)
   })
   ```

3. **After MarkFailed** (both the Send-error path and context-cancelled path): Checkpoint Failed status with error.
   ```go
   r.checkpoint(func(s persistence.Store) error {
       return s.UpdateTaskStatus(ctx, task.ID, scheduler.TaskFailed, "", taskErr)
   })
   ```

Add a helper `backendType(task, cfg)` that looks up the backend type from `cfg.BackendConfigs[task.AgentRole].Type`. Return "unknown" if not found (defensive).

Also modify the `Run` method to persist all tasks to the Store at the start (before execution begins), so the full DAG structure is captured:
```go
if r.config.Store != nil {
    for _, task := range r.dag.Tasks() {
        if err := r.config.Store.SaveTask(ctx, task); err != nil {
            log.Printf("WARNING: failed to persist task %q: %v", task.ID, err)
        }
    }
}
```

Add a `Resume` method on `*ParallelRunner`:
```go
func (r *ParallelRunner) Resume(ctx context.Context) ([]TaskResult, error)
```

Resume does:
1. Load all tasks from Store via `ListTasks`
2. Create a new DAG and add each task (preserving their persisted Status)
3. Validate the DAG (cycle detection)
4. Set `r.dag` to the reconstructed DAG
5. For each task that has a persisted session, look up the session and update the BackendConfigs entry for that task's agent role to include the SessionID (so the backend adapter uses `--resume`/`resume` on next Send)
6. Call `r.Run(ctx)` to continue execution -- the existing Run logic already calls `dag.Eligible()` which skips Completed/Failed tasks

Important: Resume does NOT re-execute Completed or Failed tasks. The DAG's `Eligible()` method already handles this -- tasks with status != TaskPending are not returned as eligible.

For session restoration, create a `sessionMap` that maps taskID -> sessionID, and a modified `createBackend` path that checks the session map before creating the backend, setting `cfg.SessionID` from the persisted value.

Add a `sessions` field to ParallelRunner: `sessions map[string]string` (taskID -> sessionID). Populate in Resume. Check in createBackend.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go build ./internal/orchestrator/` -- must compile without errors.
  </verify>
  <done>ParallelRunner checkpoints on every task state transition. Session IDs and conversation history saved after each task. Resume method reconstructs DAG from Store and continues execution from last checkpoint. Existing tests still compile (Store is optional/nil).</done>
</task>

<task type="auto">
  <name>Task 2: Checkpoint and resume tests</name>
  <files>
    internal/orchestrator/runner_test.go
  </files>
  <action>
Add tests that use an in-memory persistence Store to verify checkpoint and resume behavior.

Create a helper `testStoreForRunner(t)` that creates an in-memory `persistence.NewMemoryStore(ctx)`, registers cleanup, and returns it.

**Checkpoint tests:**

1. `TestCheckpointOnTaskCompletion` -- Create a DAG with 1 task, configure ParallelRunner with Store and mock BackendFactory (returns canned response with a session ID). Run the DAG. After Run completes, query the Store directly:
   - `store.GetTask(ctx, taskID)` should return status=TaskCompleted with the result
   - `store.GetSession(ctx, taskID)` should return the session ID and correct backend type
   - `store.GetHistory(ctx, taskID)` should return 2 turns (user prompt, assistant response)

2. `TestCheckpointOnTaskFailure` -- Create a DAG with 1 task, configure BackendFactory to return an error on Send. Run the DAG. Query Store:
   - `store.GetTask(ctx, taskID)` should return status=TaskFailed with error string

3. `TestCheckpointNilStoreNoError` -- Create ParallelRunner with Store=nil. Run a simple DAG. Verify no panic, no error -- nil Store is silently skipped.

**Resume tests:**

4. `TestResumeSkipsCompletedTasks` -- Core test for STATE-03. Steps:
   a. Create a Store with 3 tasks persisted: task-1 (Completed), task-2 (Completed), task-3 (Pending, depends on task-1 and task-2)
   b. Create ParallelRunner with the Store and a tracking BackendFactory that records which task IDs it receives
   c. Call Resume(ctx)
   d. Verify the BackendFactory was called exactly ONCE (for task-3 only)
   e. Verify task-3 is now Completed in the Store

5. `TestResumeRestoresSessionID` -- Steps:
   a. Persist a task as Completed with a session ID in the Store
   b. Persist a second task as Pending (depends on first)
   c. Create ParallelRunner with Store and BackendFactory that captures the Config it receives
   d. Call Resume -- for task-2 execution, verify the backend was NOT given a session ID (it's a new task, not a resume of an existing conversation)
   e. This test validates that session IDs are stored but only used when resuming an interrupted task (future multi-turn support)

Use the existing mock patterns from `runner_test.go` (tracking BackendFactory, fake WorktreeManager). The mock WorktreeManager and BackendFactory patterns should already be established in the existing test file -- reuse them.

All tests must use `-race` flag.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go test -race -v ./internal/orchestrator/` -- all tests (existing + new) must pass.
Run `cd /Users/aristath/orchestrator && go test -race ./...` -- full test suite must pass.
  </verify>
  <done>5 new tests prove: task state checkpointed on completion and failure, nil Store causes no errors, Resume skips completed tasks and only executes pending ones, session IDs are persisted and retrievable. Full test suite passes with -race.</done>
</task>

</tasks>

<verification>
- `go build ./...` compiles all packages
- `go test -race ./...` passes entire test suite
- `go vet ./...` reports no issues
- Resume test proves completed tasks are NOT re-executed
- Checkpoint test proves task state survives through Store
</verification>

<success_criteria>
- ParallelRunner persists task status on every transition (Running, Completed, Failed)
- Session IDs and backend types saved after each successful task execution
- Conversation prompts and responses saved per task
- Resume loads DAG from Store, skips completed tasks, runs only pending/eligible
- Store=nil is handled gracefully (no panics, no errors)
- All existing tests continue to pass (backward compatible)
- 5+ new tests pass with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-management-session-persistence/05-03-SUMMARY.md`
</output>
