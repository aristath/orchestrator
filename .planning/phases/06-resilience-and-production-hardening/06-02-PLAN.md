---
phase: 06-resilience-and-production-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/orchestrator/main.go
autonomous: true

must_haves:
  truths:
    - "Pressing Ctrl+C triggers graceful shutdown: context cancels, subprocess trees are killed, orchestrator exits cleanly"
    - "A 10-second shutdown timeout prevents the orchestrator from hanging if cleanup stalls"
    - "Double Ctrl+C forces immediate exit via standard Go signal behavior"
    - "Database connections and event bus are closed during shutdown"
  artifacts:
    - path: "cmd/orchestrator/main.go"
      provides: "Signal handling with graceful shutdown, ProcessManager integration"
      contains: "signal.NotifyContext"
  key_links:
    - from: "cmd/orchestrator/main.go"
      to: "ProcessManager.KillAll"
      via: "shutdown handler calls KillAll on signal"
      pattern: "KillAll"
    - from: "cmd/orchestrator/main.go"
      to: "signal.NotifyContext"
      via: "context cancellation on SIGINT/SIGTERM"
      pattern: "signal\\.NotifyContext"
---

<objective>
Implement graceful shutdown with signal handling in the orchestrator entry point.

Purpose: RESIL-04 — pressing Ctrl+C triggers clean shutdown: all subprocess trees are killed via ProcessManager, partial work is checkpointed (handled by runner's existing checkpoint logic reacting to context cancellation), and the orchestrator exits cleanly within a 10-second timeout.

Output: Updated `cmd/orchestrator/main.go` with signal-aware context, shutdown handler, and ProcessManager integration.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-resilience-and-production-hardening/06-RESEARCH.md
@cmd/orchestrator/main.go
@internal/backend/process.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add signal handling and graceful shutdown to main.go</name>
  <files>cmd/orchestrator/main.go</files>
  <action>
Rewrite `cmd/orchestrator/main.go` to replace the current demo/TUI-only entry point with a production-ready entry point that includes signal handling and graceful shutdown.

The current main.go creates a TUI with fake events. Replace with a structure that:

1. **Creates a signal-aware context** at the top of main():
   ```go
   ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
   defer stop()
   ```

2. **Creates ProcessManager** for subprocess tracking:
   ```go
   pm := backend.NewProcessManager()
   ```

3. **Loads config** (keep existing config loading logic).

4. **Determines config paths** (keep existing logic for globalPath, projectPath).

5. **Creates event bus** (keep existing logic, with defer bus.Close()).

6. **Creates TUI model** (keep existing logic).

7. **Starts the Bubble Tea program** in a goroutine so main can handle shutdown:
   ```go
   p := tea.NewProgram(model, tea.WithAltScreen())

   errChan := make(chan error, 1)
   go func() {
       _, err := p.Run()
       errChan <- err
   }()
   ```

8. **Handles shutdown** with select:
   ```go
   select {
   case err := <-errChan:
       // Normal TUI exit (user pressed 'q' or TUI finished)
       if err != nil {
           fmt.Fprintf(os.Stderr, "Error: %v\n", err)
           os.Exit(1)
       }
   case <-ctx.Done():
       // Signal received (Ctrl+C or SIGTERM)
       // Call stop() to restore default signal handling (double Ctrl+C = force exit)
       stop()

       log.Println("Shutdown signal received, cleaning up...")

       // Kill all tracked subprocesses
       if err := pm.KillAll(); err != nil {
           log.Printf("Error killing subprocesses: %v", err)
       }

       // Quit the TUI
       p.Quit()

       // Wait for TUI to exit with timeout
       shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
       defer cancel()

       select {
       case err := <-errChan:
           if err != nil {
               log.Printf("TUI exit error: %v", err)
           }
       case <-shutdownCtx.Done():
           log.Println("Shutdown timeout exceeded, forcing exit")
       }
   }

   log.Println("Shutdown complete")
   ```

9. **Remove the fake event goroutine** (the `go func()` block that publishes demo events). Replace with a comment:
   ```go
   // TODO: Wire ParallelRunner here when DAG execution is integrated with TUI.
   // The runner will publish real events to the bus.
   // For now, TUI starts empty and waits for events.
   ```

10. **Add imports**: `context`, `log`, `os/signal`, `syscall`, `time` (in addition to existing imports). Import `github.com/aristath/orchestrator/internal/backend` for ProcessManager.

The key architectural points:
- `signal.NotifyContext` creates a context that cancels on SIGINT/SIGTERM
- Calling `stop()` after `ctx.Done()` restores default signal handling so a second Ctrl+C immediately kills the process (standard Go pattern for double-signal force exit)
- ProcessManager.KillAll() sends SIGKILL to all subprocess process groups (already implemented in Phase 1)
- 10-second timeout prevents hanging if TUI or cleanup stalls
- Event bus and store are cleaned up via defers
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go build ./cmd/orchestrator/...` — should compile without errors.
Run `cd /Users/aristath/orchestrator && go vet ./cmd/orchestrator/...` — no warnings.
  </verify>
  <done>
- main.go uses signal.NotifyContext for SIGINT/SIGTERM handling
- Ctrl+C triggers context cancellation, KillAll, TUI quit, and clean exit
- 10-second shutdown timeout prevents hanging
- Double Ctrl+C forces immediate exit (standard pattern via stop() call)
- ProcessManager integrated for subprocess cleanup
- No fake demo events — clean entry point ready for runner integration
  </done>
</task>

<task type="auto">
  <name>Task 2: Add graceful shutdown integration test</name>
  <files>cmd/orchestrator/main_test.go</files>
  <action>
Create `cmd/orchestrator/main_test.go` with a test that verifies the signal handling pattern works correctly.

Since we cannot easily test the full TUI + signal flow in a unit test (Bubble Tea requires a terminal), create a focused test that verifies the core shutdown logic:

1. **TestProcessManagerKillAllOnShutdown**: Verify that ProcessManager.KillAll() correctly terminates tracked processes during simulated shutdown.
   - Create a ProcessManager
   - Start a long-running subprocess (`sleep 60`) with Setpgid:true
   - Track it with pm.Track()
   - Call pm.KillAll()
   - Verify the process is no longer running (cmd.Wait() returns)
   - Verify pm.Count() is still > 0 after KillAll (KillAll doesn't untrack, that happens in executeCommand's defer)

2. **TestSignalContextCancellation**: Verify that signal.NotifyContext produces a context that cancels correctly.
   - Create signal context with signal.NotifyContext for SIGUSR1 (safe test signal)
   - Send SIGUSR1 to self: `syscall.Kill(os.Getpid(), syscall.SIGUSR1)`
   - Verify ctx.Done() is closed within 1 second
   - Call stop() to clean up

3. **TestShutdownTimeout**: Verify the timeout pattern works.
   - Create a context with 50ms timeout
   - Start a select that waits for a channel that never receives, or ctx.Done()
   - Verify ctx.Done() fires within 100ms (the timeout worked)

Keep tests simple and fast (no TUI, no Bubble Tea). These test the building blocks that main.go composes.

Import `os/exec`, `os`, `os/signal`, `syscall`, `context`, `testing`, `time`, and `github.com/aristath/orchestrator/internal/backend`.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go test -race -v ./cmd/orchestrator/... -count=1` — all tests pass.
  </verify>
  <done>
- ProcessManager.KillAll() terminates tracked subprocesses (test proves it)
- Signal context cancels on signal delivery (test proves it)
- Shutdown timeout fires correctly (test proves it)
- All tests pass with -race flag
  </done>
</task>

</tasks>

<verification>
1. `go test -race -v ./cmd/orchestrator/... -count=1` — all tests pass
2. `go build ./cmd/orchestrator/...` — compiles
3. `go vet ./cmd/orchestrator/...` — no warnings
4. Verify main.go contains `signal.NotifyContext` and `pm.KillAll()`
5. Verify main.go calls `stop()` after ctx.Done() for double-signal force exit
</verification>

<success_criteria>
- Ctrl+C triggers graceful shutdown: context cancels, subprocesses killed, clean exit (RESIL-04)
- 10-second timeout prevents hanging on stalled cleanup
- Double Ctrl+C forces immediate exit
- ProcessManager integrated in main for subprocess lifecycle
- Shutdown tests pass with -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/06-resilience-and-production-hardening/06-02-SUMMARY.md`
</output>
