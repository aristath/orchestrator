---
phase: 04-event-bus-tui-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/tui/model.go
  - internal/tui/agent_pane.go
  - internal/tui/dag_pane.go
  - internal/tui/styles.go
  - internal/tui/keys.go
autonomous: true

must_haves:
  truths:
    - "TUI displays a split-pane layout with agent list on left, agent output viewport on right-top, and DAG progress on right-bottom"
    - "User can switch focus between panes using vim-style keybindings (Tab to cycle, 1/2/3 for direct pane selection)"
    - "Each agent pane shows a status indicator (working/failed/complete) visible without switching focus"
    - "DAG pane shows task counts (completed/running/failed/pending of total) updated in real-time"
    - "Agent output viewport scrolls automatically and shows real-time output with debouncing"
    - "Terminal resize updates all panes correctly"
  artifacts:
    - path: "internal/tui/model.go"
      provides: "Root Bubble Tea model with split-pane layout and message routing"
      exports: ["Model", "New"]
      min_lines: 100
    - path: "internal/tui/agent_pane.go"
      provides: "Agent list and output viewport pane"
      exports: ["AgentPaneModel"]
      min_lines: 80
    - path: "internal/tui/dag_pane.go"
      provides: "DAG progress display pane"
      exports: ["DAGPaneModel"]
      min_lines: 50
    - path: "internal/tui/styles.go"
      provides: "Lipgloss style definitions for all panes"
      min_lines: 20
    - path: "internal/tui/keys.go"
      provides: "Keybinding definitions"
      min_lines: 15
  key_links:
    - from: "internal/tui/model.go"
      to: "internal/events/bus.go"
      via: "SubscribeAll in New() constructor"
      pattern: "SubscribeAll"
    - from: "internal/tui/model.go"
      to: "internal/tui/agent_pane.go"
      via: "AgentPaneModel field and Update delegation"
      pattern: "agentPane"
    - from: "internal/tui/model.go"
      to: "internal/tui/dag_pane.go"
      via: "DAGPaneModel field and Update delegation"
      pattern: "dagPane"
    - from: "internal/tui/agent_pane.go"
      to: "internal/events/types.go"
      via: "Handling TaskStartedEvent, TaskOutputEvent, TaskCompletedEvent"
      pattern: "TaskStartedEvent|TaskCompletedEvent"
---

<objective>
Build the Bubble Tea TUI with split-pane layout, agent viewports, DAG progress, vim navigation, and real-time event consumption.

Purpose: This is the core user interface. Users will see all running agents simultaneously, switch between them, and monitor overall DAG progress -- fulfilling requirements TUI-01 through TUI-05.

Output: `internal/tui/` package with root model, agent pane, DAG pane, styles, and keybindings. Fully functional TUI that consumes events from the event bus (Plan 01).
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-event-bus-tui-integration/04-RESEARCH.md
@.planning/phases/04-event-bus-tui-integration/04-01-SUMMARY.md
@internal/events/bus.go
@internal/events/types.go
@internal/scheduler/task.go
@internal/config/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: TUI root model, styles, keybindings, and pane models</name>
  <files>internal/tui/model.go, internal/tui/agent_pane.go, internal/tui/dag_pane.go, internal/tui/styles.go, internal/tui/keys.go</files>
  <action>
Install Bubble Tea v2 and Lipgloss v2 dependencies:
```bash
cd /Users/aristath/orchestrator && go get github.com/charmbracelet/bubbletea/v2 && go get github.com/charmbracelet/lipgloss/v2 && go get github.com/charmbracelet/bubbles
```

IMPORTANT: Use Bubble Tea v2 import paths. Check the actual v2 API carefully -- `View()` in v2 returns `string` (same as v1). Key handling uses `tea.KeyMsg` with `msg.String()` method. WindowSizeMsg is `tea.WindowSizeMsg`. The research mentions `tea.View` structs but this may be inaccurate for the current stable release -- verify by reading go doc after installing, and use whichever API the installed version provides.

Create 5 files in `internal/tui/`:

**styles.go** -- Lipgloss style definitions:
- `StyleFocusedBorder` -- bright border color (lipgloss.Color("62") cyan-ish) with RoundedBorder
- `StyleUnfocusedBorder` -- dim border color (lipgloss.Color("240") gray) with RoundedBorder
- `StyleStatusRunning` -- yellow foreground, bold
- `StyleStatusComplete` -- green foreground, bold
- `StyleStatusFailed` -- red foreground, bold
- `StyleStatusPending` -- gray foreground
- `StyleTitle` -- bold, padding(0, 1)
- `StyleHelp` -- dim foreground for help text at bottom

**keys.go** -- Keybinding constants and help text:
- Tab / Shift+Tab to cycle focus forward/backward between panes
- 1, 2, 3 to jump directly to agent list, agent output, DAG pane
- q / ctrl+c to quit
- Up/Down/j/k for scrolling within focused pane (delegated to viewport)
- s to toggle settings panel (reserved for Plan 03)
- Define a `HelpView() string` function that returns a one-line help bar

**dag_pane.go** -- DAG progress pane:
```go
type DAGPaneModel struct {
    total     int
    completed int
    running   int
    failed    int
    pending   int
    width     int
    height    int
    focused   bool
}
```
Methods:
- `NewDAGPaneModel() DAGPaneModel`
- `Update(msg tea.Msg) (DAGPaneModel, tea.Cmd)` -- handles WindowSizeMsg to store dimensions. Handles DAGProgressEvent to update counts.
- `View() string` -- render a compact status display:
  ```
  DAG Progress
  ============
  Total:     12
  Completed:  5  [green]
  Running:    2  [yellow]
  Failed:     1  [red]
  Pending:    4  [gray]

  [=====--.....]  5/12
  ```
  Use a simple text-based progress bar. Apply styling based on state. Respect width/height constraints.
- `SetSize(w, h int)` -- update dimensions
- `SetFocused(focused bool)` -- update focus state for border styling

**agent_pane.go** -- Agent list + output viewport:
```go
type AgentState struct {
    TaskID    string
    Name      string
    AgentRole string
    Status    string // "running", "completed", "failed"
    Output    []string
    StartTime time.Time
    Duration  time.Duration
}

type AgentPaneModel struct {
    agents       map[string]*AgentState // taskID -> state
    agentOrder   []string               // insertion order for display
    selectedIdx  int                    // which agent is selected in list
    viewport     viewport.Model         // scrollable output viewport
    width        int
    height       int
    focused      bool
    updateTag    int                    // for debouncing
}
```

Methods:
- `NewAgentPaneModel() AgentPaneModel` -- initialize with empty agents map, create viewport
- `Update(msg tea.Msg) (AgentPaneModel, tea.Cmd)` -- handle:
  - `tea.WindowSizeMsg` to resize viewport
  - `tea.KeyMsg` for j/k/up/down to select different agent in list, viewport scrolling
  - Event messages (TaskStartedEvent, TaskOutputEvent, TaskCompletedEvent, TaskFailedEvent) to update agent states. On TaskOutputEvent, append to selected agent's Output and update viewport content. Use debouncing: increment updateTag, return tea.Tick(50ms) cmd, only update viewport content when tag matches (prevents render thrashing from high-frequency output).
- `View() string` -- two-column sub-layout:
  - Left narrow column (~20 chars): agent list with status indicator icons. Use colored dot or symbol: yellow spinner-like char for running, green checkmark for completed, red X for failed. Selected agent highlighted.
  - Right wide column: viewport showing selected agent's output. If no agents yet, show "Waiting for tasks..." placeholder.
- `SetSize(w, h int)` -- update dimensions, resize viewport
- `SetFocused(focused bool)` -- update focus for border styling
- `StatusIcon(status string) string` -- returns styled status indicator

Use `github.com/charmbracelet/bubbles/viewport` for the scrollable output area.

**model.go** -- Root TUI model:
```go
type PaneID int
const (
    PaneAgentList PaneID = iota
    PaneAgentOutput
    PaneDAG
)

type Model struct {
    agentPane   AgentPaneModel
    dagPane     DAGPaneModel
    focusedPane PaneID
    eventSub    <-chan events.Event
    width       int
    height      int
    quitting    bool
}
```

Constructor: `New(eventBus *events.EventBus) Model` -- use `eventBus.SubscribeAll(256)` to get a SINGLE channel that receives events from ALL topics (both TopicTask and TopicDAG). Store this single channel as `eventSub`. This avoids the need to merge multiple topic channels.

`Init() tea.Cmd` -- return a command that waits for the first event from eventSub channel:
```go
func waitForEvent(sub <-chan events.Event) tea.Cmd {
    return func() tea.Msg {
        event, ok := <-sub
        if !ok {
            return nil // bus closed
        }
        return event
    }
}
```

`Update(msg tea.Msg) (tea.Model, tea.Cmd)` -- message routing:
1. `tea.KeyMsg`:
   - "q", "ctrl+c" -> set quitting=true, return tea.Quit
   - "tab" -> cycle focusedPane forward (0->1->2->0)
   - "shift+tab" -> cycle backward
   - "1" -> PaneAgentList
   - "2" -> PaneAgentOutput
   - "3" -> PaneDAG
   - Otherwise: delegate to focused pane's Update
2. `tea.WindowSizeMsg` -> store width/height, compute pane dimensions, broadcast to ALL child models via SetSize
3. Event types (TaskStartedEvent, TaskOutputEvent, etc.) -> forward to agentPane.Update AND dagPane.Update. Then return waitForEvent cmd to listen for next event.

**Layout computation** in View():
- Left column (agent pane): width = 35% of terminal, full height minus 1 (help bar)
- Right-top (agent output): width = 65% of terminal, height = 70% of available
- Right-bottom (DAG pane): width = 65% of terminal, height = 30% of available
- Bottom: help bar (full width, 1 line)

Use lipgloss.JoinHorizontal and JoinVertical to compose the layout. Apply focused/unfocused border styles based on focusedPane.

`View() string`:
```go
leftPane := lipgloss style with border + agentPane.View()
rightTop := lipgloss style with border + agentOutput part
rightBottom := lipgloss style with border + dagPane.View()
rightPane := lipgloss.JoinVertical(lipgloss.Left, rightTop, rightBottom)
main := lipgloss.JoinHorizontal(lipgloss.Top, leftPane, rightPane)
return lipgloss.JoinVertical(lipgloss.Left, main, HelpView())
```

Run `go build ./internal/tui/...` to verify compilation.
  </action>
  <verify>
`go build ./internal/tui/...` compiles without errors.
`go vet ./internal/tui/...` reports no issues.
`go build ./internal/...` -- full project still builds.
`go test -race ./internal/...` -- no regressions in existing tests.
  </verify>
  <done>
TUI package exists with root model, agent pane (list + viewport), DAG pane, styles, and keybindings. Layout renders split-pane view. Event subscription uses SubscribeAll for a single channel receiving all topics. Focus navigation works with Tab/Shift+Tab/1/2/3. All code compiles and existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Main entry point and manual smoke test</name>
  <files>cmd/orchestrator/main.go</files>
  <action>
Create `cmd/orchestrator/main.go` as the application entry point that wires everything together for manual testing.

```go
package main

import (
    "fmt"
    "os"
    "time"

    tea "github.com/charmbracelet/bubbletea/v2"

    "github.com/aristath/orchestrator/internal/events"
    "github.com/aristath/orchestrator/internal/tui"
)

func main() {
    // Create event bus
    bus := events.NewEventBus()
    defer bus.Close()

    // Create TUI model
    model := tui.New(bus)

    // Start Bubble Tea program
    p := tea.NewProgram(model, tea.WithAltScreen())

    // Spawn a goroutine that publishes fake events for demo/testing
    go func() {
        time.Sleep(500 * time.Millisecond)

        // Simulate task-1 starting
        bus.Publish(events.TopicTask, events.TaskStartedEvent{
            ID: "task-1", Name: "Implement auth", AgentRole: "coder",
            Timestamp: time.Now(),
        })

        // Simulate some output
        for i := 0; i < 20; i++ {
            time.Sleep(100 * time.Millisecond)
            bus.Publish(events.TopicTask, events.TaskOutputEvent{
                ID: "task-1", Line: fmt.Sprintf("[task-1] Working on auth... step %d", i+1),
                Timestamp: time.Now(),
            })
        }

        // Simulate task-2 starting
        bus.Publish(events.TopicTask, events.TaskStartedEvent{
            ID: "task-2", Name: "Write tests", AgentRole: "tester",
            Timestamp: time.Now(),
        })

        // DAG progress
        bus.Publish(events.TopicDAG, events.DAGProgressEvent{
            Total: 5, Completed: 0, Running: 2, Failed: 0, Pending: 3,
            Timestamp: time.Now(),
        })

        // More output interleaved
        for i := 0; i < 10; i++ {
            time.Sleep(150 * time.Millisecond)
            bus.Publish(events.TopicTask, events.TaskOutputEvent{
                ID: "task-2", Line: fmt.Sprintf("[task-2] Running test suite... %d/10", i+1),
                Timestamp: time.Now(),
            })
            bus.Publish(events.TopicTask, events.TaskOutputEvent{
                ID: "task-1", Line: fmt.Sprintf("[task-1] Auth implementation continued... %d", i+21),
                Timestamp: time.Now(),
            })
        }

        // Complete task-1
        bus.Publish(events.TopicTask, events.TaskCompletedEvent{
            ID: "task-1", Result: "Auth implemented successfully",
            Duration: 5 * time.Second, Timestamp: time.Now(),
        })

        bus.Publish(events.TopicDAG, events.DAGProgressEvent{
            Total: 5, Completed: 1, Running: 1, Failed: 0, Pending: 3,
            Timestamp: time.Now(),
        })

        // Complete task-2
        time.Sleep(1 * time.Second)
        bus.Publish(events.TopicTask, events.TaskCompletedEvent{
            ID: "task-2", Result: "All tests passed",
            Duration: 3 * time.Second, Timestamp: time.Now(),
        })

        bus.Publish(events.TopicDAG, events.DAGProgressEvent{
            Total: 5, Completed: 2, Running: 0, Failed: 0, Pending: 3,
            Timestamp: time.Now(),
        })
    }()

    if _, err := p.Run(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}
```

This is a demo entry point. It verifies the TUI actually renders, handles events, and navigates correctly. The fake event goroutine simulates a real orchestrator run.

Build and verify: `go build -o /tmp/orchestrator-demo ./cmd/orchestrator/`
  </action>
  <verify>
`go build -o /tmp/orchestrator-demo ./cmd/orchestrator/` compiles successfully.
`go build ./...` -- entire project builds.
`go vet ./...` -- no issues.
`go test -race ./internal/...` -- all tests pass, no regressions.
  </verify>
  <done>
Main entry point exists at cmd/orchestrator/main.go. Binary compiles and can be run manually to see the TUI with fake events demonstrating split-pane layout, agent output, DAG progress, and keyboard navigation.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` -- entire project including TUI and main compiles
2. `go vet ./...` -- no vet issues
3. `go test -race ./internal/...` -- full test suite passes, no regressions
4. `/tmp/orchestrator-demo` runs, displays split-pane TUI, and exits cleanly with q
5. Agent panes show status indicators and real-time output
6. Tab/1/2/3 keys navigate between panes
7. DAG pane shows progress counts
</verification>

<success_criteria>
- Split-pane TUI renders with agent list, agent output viewport, and DAG progress pane
- Vim-style navigation (Tab, Shift+Tab, 1/2/3) switches focus between panes
- Events from event bus appear in real-time in agent panes with status indicators
- DAG progress updates with task counts
- Terminal resize handled correctly
- Binary compiles and runs
</success_criteria>

<output>
After completion, create `.planning/phases/04-event-bus-tui-integration/04-02-SUMMARY.md`
</output>
