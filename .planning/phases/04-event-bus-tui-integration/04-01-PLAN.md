---
phase: 04-event-bus-tui-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/events/bus.go
  - internal/events/types.go
  - internal/events/bus_test.go
  - internal/orchestrator/runner.go
  - internal/orchestrator/runner_test.go
autonomous: true

must_haves:
  truths:
    - "ParallelRunner publishes TaskStarted, TaskCompleted, TaskFailed, and TaskOutput events during execution"
    - "Event bus delivers published events to all subscribers without blocking the publisher"
    - "Slow or full subscriber channels do not block task execution"
    - "Event bus can be cleanly shut down, closing all subscriber channels"
  artifacts:
    - path: "internal/events/bus.go"
      provides: "Channel-based pubsub event bus with topic subscriptions"
      exports: ["EventBus", "NewEventBus", "Subscribe", "Publish", "Close"]
    - path: "internal/events/types.go"
      provides: "Event type definitions for orchestrator lifecycle"
      contains: "TaskStartedEvent"
    - path: "internal/events/bus_test.go"
      provides: "Event bus unit tests"
      min_lines: 80
    - path: "internal/orchestrator/runner.go"
      provides: "ParallelRunner instrumented with event publishing"
      contains: "EventBus"
  key_links:
    - from: "internal/orchestrator/runner.go"
      to: "internal/events/bus.go"
      via: "EventBus field in ParallelRunnerConfig"
      pattern: "EventBus.*Publish"
    - from: "internal/events/bus.go"
      to: "internal/events/types.go"
      via: "Event interface used in bus methods"
      pattern: "Event"
---

<objective>
Create a channel-based event bus and instrument the ParallelRunner to publish task lifecycle events.

Purpose: Decouple orchestrator execution from TUI rendering. The event bus is the foundation that allows the TUI (Plan 02) to observe task execution without blocking it.

Output: `internal/events/` package with EventBus and event types; ParallelRunner modified to accept an optional EventBus and publish events at key lifecycle points.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-event-bus-tui-integration/04-RESEARCH.md
@internal/orchestrator/runner.go
@internal/orchestrator/runner_test.go
@internal/scheduler/task.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Event bus and event types</name>
  <files>internal/events/bus.go, internal/events/types.go, internal/events/bus_test.go</files>
  <action>
Create `internal/events/` package with two source files and tests.

**types.go** -- Define the Event interface and concrete event types:

```go
type Event interface {
    EventType() string
    TaskID() string
}
```

Concrete event types (all implementing Event):
- `TaskStartedEvent` -- fields: ID (task ID), Name (task name), AgentRole string, Timestamp time.Time
- `TaskOutputEvent` -- fields: ID (task ID), Line string, Timestamp time.Time
- `TaskCompletedEvent` -- fields: ID (task ID), Result string, Duration time.Duration, Timestamp time.Time
- `TaskFailedEvent` -- fields: ID (task ID), Err error, Duration time.Duration, Timestamp time.Time
- `TaskMergedEvent` -- fields: ID (task ID), Merged bool, ConflictFiles []string, Timestamp time.Time
- `DAGProgressEvent` -- fields: Total, Completed, Running, Failed, Pending int, Timestamp time.Time

Each event type has methods: `EventType() string` returning a constant like "task.started", and `TaskID() string` returning the ID field (or "" for DAGProgressEvent).

Define topic constants: `TopicTask = "task"`, `TopicDAG = "dag"`.

**bus.go** -- Implement channel-based pubsub following Eli Bendersky's pattern from the research:

```go
type EventBus struct {
    mu     sync.RWMutex
    subs   map[string][]chan Event
    closed bool
}
```

Methods:
- `NewEventBus() *EventBus` -- initializes subs map
- `Subscribe(topic string, bufSize int) <-chan Event` -- creates buffered channel of given size, appends to subs[topic], returns read-only channel. If bufSize <= 0, default to 256.
- `Publish(topic string, event Event)` -- non-blocking send with `select/default` (drop if channel full). Return immediately if closed. Use RLock for concurrent publishers.
- `Close()` -- set closed=true, close all subscriber channels. Use write lock. Idempotent (safe to call twice).

**bus_test.go** -- Tests:
1. `TestPublishSubscribe` -- subscribe, publish, verify received
2. `TestMultipleSubscribers` -- two subscribers both receive same event
3. `TestNonBlockingSend` -- subscribe with buffer=1, publish 10 events, verify no deadlock (publisher returns immediately)
4. `TestCloseSignalsSubscribers` -- subscribe, close bus, verify channel is closed (range loop exits)
5. `TestPublishAfterClose` -- close bus, publish, verify no panic
6. `TestMultipleTopics` -- subscribe to different topics, verify isolation

Run: `go test -race ./internal/events/...`
  </action>
  <verify>
`go build ./internal/events/...` succeeds.
`go vet ./internal/events/...` reports no issues.
`go test -race -v ./internal/events/...` -- all 6 tests pass with no race conditions.
  </verify>
  <done>
EventBus with topic-based subscriptions, non-blocking publish, and clean shutdown exists in internal/events/. All 6 tests pass under -race flag.
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument ParallelRunner with event publishing</name>
  <files>internal/orchestrator/runner.go, internal/orchestrator/runner_test.go</files>
  <action>
Modify ParallelRunner to accept an optional EventBus and publish events during task execution.

**runner.go changes:**

1. Add import for `"github.com/aristath/orchestrator/internal/events"`

2. Add `EventBus *events.EventBus` field to `ParallelRunnerConfig` (optional, nil disables event publishing).

3. Add helper method on ParallelRunner:
```go
func (r *ParallelRunner) publish(topic string, event events.Event) {
    if r.config.EventBus != nil {
        r.config.EventBus.Publish(topic, event)
    }
}
```

4. In `executeTask()`, publish events at these points:
   - After `MarkRunning`: publish `TaskStartedEvent{ID: task.ID, Name: task.Name, AgentRole: task.AgentRole, Timestamp: time.Now()}` on `events.TopicTask`
   - After `MarkCompleted`: publish `TaskCompletedEvent{ID: task.ID, Result: resp.Content, Duration: time.Since(startTime), Timestamp: time.Now()}` on `events.TopicTask`. Add `startTime := time.Now()` at the top of executeTask.
   - After `MarkFailed` (all 3 failure paths): publish `TaskFailedEvent{ID: task.ID, Err: <the error>, Duration: time.Since(startTime), Timestamp: time.Now()}` on `events.TopicTask`
   - After merge result: publish `TaskMergedEvent{ID: task.ID, Merged: mergeResult.Merged, ConflictFiles: mergeResult.ConflictFiles, Timestamp: time.Now()}` on `events.TopicTask`

5. In `Run()`, after each wave completes (after `g.Wait()`), publish a `DAGProgressEvent` with counts computed from `r.dag.Tasks()`:
```go
func (r *ParallelRunner) publishProgress() {
    tasks := r.dag.Tasks()
    var total, completed, running, failed, pending int
    total = len(tasks)
    for _, t := range tasks {
        switch t.Status {
        case scheduler.TaskCompleted:
            completed++
        case scheduler.TaskRunning:
            running++
        case scheduler.TaskFailed:
            failed++
        default:
            pending++
        }
    }
    r.publish(events.TopicDAG, events.DAGProgressEvent{
        Total: total, Completed: completed, Running: running, Failed: failed, Pending: pending,
        Timestamp: time.Now(),
    })
}
```

**runner_test.go changes:**

Add one new test (do NOT modify existing tests):

`TestEventBusIntegration` -- Create EventBus, subscribe to TopicTask and TopicDAG, run a simple 2-task DAG, verify:
- Received at least 2 TaskStartedEvent (one per task)
- Received at least 2 TaskCompletedEvent (one per task)
- Received at least 1 DAGProgressEvent
- All events have non-zero timestamps

Also verify existing tests still pass (EventBus=nil should not change behavior).

Note: If `mergeResult.ConflictFiles` does not exist on the worktree.MergeResult struct, use an empty slice. Check the actual MergeResult struct fields before referencing them.

Run: `go test -race ./internal/orchestrator/...`
  </action>
  <verify>
`go build ./internal/...` succeeds.
`go vet ./internal/...` reports no issues.
`go test -race -v ./internal/orchestrator/...` -- all existing tests still pass, plus new TestEventBusIntegration passes.
`go test -race ./internal/...` -- full test suite passes with no regressions.
  </verify>
  <done>
ParallelRunner publishes TaskStarted, TaskCompleted, TaskFailed, TaskMerged, and DAGProgress events through the event bus when configured. All existing tests pass unchanged (EventBus=nil). New integration test verifies event delivery.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/...` -- entire project builds
2. `go vet ./internal/...` -- no vet issues
3. `go test -race ./internal/...` -- full test suite passes, no regressions
4. Event bus subscribes, publishes, and closes without deadlocks
5. ParallelRunner publishes events at all task lifecycle points
6. Setting EventBus=nil does not change existing behavior
</verification>

<success_criteria>
- internal/events/ package exists with EventBus, 6 event types, and passing tests
- ParallelRunner accepts optional EventBus and publishes lifecycle events
- All existing tests pass unchanged
- No race conditions under -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/04-event-bus-tui-integration/04-01-SUMMARY.md`
</output>
