---
phase: 02-agent-definitions-and-dag-scheduler
plan: 03
type: execute
wave: 2
depends_on: ["02-02"]
files_modified:
  - internal/scheduler/locks.go
  - internal/scheduler/executor.go
  - internal/scheduler/locks_test.go
  - internal/scheduler/executor_test.go
autonomous: true

must_haves:
  truths:
    - "File-level resource locks prevent scheduling two tasks that write the same file concurrently"
    - "Task execution acquires file locks before running and releases after completion"
    - "Multiple tasks writing different files can execute concurrently"
    - "Lock acquisition uses lexicographic ordering to prevent deadlocks"
  artifacts:
    - path: "internal/scheduler/locks.go"
      provides: "ResourceLockManager with per-file mutex map"
      contains: "type ResourceLockManager struct"
    - path: "internal/scheduler/executor.go"
      provides: "Executor that runs tasks through backends with resource locking"
      contains: "type Executor struct"
    - path: "internal/scheduler/locks_test.go"
      provides: "Concurrency tests for resource locking"
      contains: "func TestResourceLockManager"
    - path: "internal/scheduler/executor_test.go"
      provides: "Tests for task execution with mocked backend"
      contains: "func TestExecutor"
  key_links:
    - from: "internal/scheduler/executor.go"
      to: "internal/scheduler/locks.go"
      via: "Executor acquires/releases file locks around task execution"
      pattern: "lockMgr\\.Lock"
    - from: "internal/scheduler/executor.go"
      to: "internal/scheduler/dag.go"
      via: "Executor marks tasks running/completed/failed in DAG"
      pattern: "dag\\.Mark"
    - from: "internal/scheduler/executor.go"
      to: "internal/backend/backend.go"
      via: "Executor sends task prompt to backend"
      pattern: "backend\\.Send"
---

<objective>
Resource locking and task executor that connects the DAG scheduler to backends.

Purpose: Before parallel execution (Phase 3), we need file-level resource locks to prevent concurrent writes to the same file, and an executor that bridges DAG tasks to Phase 1 backends. The executor acquires locks, dispatches to the appropriate backend, and updates task status in the DAG.

Output: Resource lock manager and task executor in `internal/scheduler/`, with tests.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-definitions-and-dag-scheduler/02-RESEARCH.md
@internal/backend/types.go
@internal/backend/backend.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Resource lock manager with per-file keyed mutex</name>
  <files>internal/scheduler/locks.go, internal/scheduler/locks_test.go</files>
  <action>
Create `internal/scheduler/locks.go`:

```go
// ResourceLockManager provides per-file mutual exclusion for concurrent task execution.
// Uses a keyed mutex pattern: each file path gets its own mutex, allowing concurrent
// writes to different files while blocking concurrent writes to the same file.
type ResourceLockManager struct {
    mu    sync.Mutex           // Guards the locks map itself
    locks map[string]*sync.Mutex // Per-file mutexes
}
```

Methods:
- `NewResourceLockManager() *ResourceLockManager`
- `Lock(filepath string)` -- acquires the per-file mutex (creates it on first access, guarded by mu to prevent race condition per research pitfall #4)
- `Unlock(filepath string)` -- releases the per-file mutex
- `LockAll(filepaths []string)` -- acquires locks for ALL given filepaths. CRITICAL: sort filepaths lexicographically BEFORE acquiring to prevent deadlocks (research pitfall #2). Acquire in sorted order.
- `UnlockAll(filepaths []string)` -- releases locks for all given filepaths. Release in reverse sorted order.

Create `internal/scheduler/locks_test.go`:

1. **Basic lock/unlock**: Lock a file, unlock it, no panic
2. **Same file blocks**: Goroutine A locks "main.go", goroutine B tries to lock "main.go" -- B blocks until A unlocks. Use a channel to verify ordering.
3. **Different files concurrent**: Goroutine A locks "a.go", goroutine B locks "b.go" -- both proceed without blocking. Use sync.WaitGroup to verify both complete quickly.
4. **LockAll ordering**: Lock ["b.go", "a.go"] -- internally sorts to ["a.go", "b.go"]. Verify no deadlock when another goroutine locks ["a.go", "b.go"] simultaneously. Run under -race.
5. **UnlockAll releases all**: LockAll, then UnlockAll, then another goroutine can LockAll the same files.

Run all tests with `-race` flag to catch data races.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go test ./internal/scheduler/ -run TestResourceLockManager -v -count=1 -race` -- all tests pass.
  </verify>
  <done>
ResourceLockManager implements per-file keyed mutex with lexicographic ordering for multi-file lock acquisition. All 5 test cases pass under -race including concurrent access patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Task executor bridging DAG to backends</name>
  <files>internal/scheduler/executor.go, internal/scheduler/executor_test.go</files>
  <action>
Create `internal/scheduler/executor.go`:

```go
// Executor runs tasks by dispatching them to backends with resource locking.
type Executor struct {
    dag      *DAG
    lockMgr  *ResourceLockManager
    backends map[string]backend.Backend // agentRole -> backend instance
}
```

Constructor: `NewExecutor(dag *DAG, lockMgr *ResourceLockManager) *Executor`

Methods:
- `RegisterBackend(agentRole string, b backend.Backend)` -- maps an agent role to a backend instance. Multiple roles can use the same backend instance.
- `ExecuteTask(ctx context.Context, taskID string) error` -- the main execution method:
  1. Get task from DAG, verify it's eligible (status == TaskEligible)
  2. Mark task as running in DAG
  3. Acquire file locks via `lockMgr.LockAll(task.WritesFiles)`
  4. Look up backend by `task.AgentRole`
  5. Send task prompt to backend: `backend.Send(ctx, backend.Message{Content: task.Prompt, Role: "user"})`
  6. Release file locks via `lockMgr.UnlockAll(task.WritesFiles)`
  7. On success: `dag.MarkCompleted(taskID, resp.Content)`
  8. On error: `dag.MarkFailed(taskID, err)`
  9. Return nil (task status is in DAG, not the return value) -- unless the task wasn't found or wasn't eligible, in which case return error
- `NextEligible() []*Task` -- convenience wrapper around `dag.Eligible()`

Important: Use `defer` for UnlockAll to ensure locks are released even on panic/error. Context cancellation from ctx should be respected -- if ctx is cancelled, return early with appropriate error and mark task failed.

Create `internal/scheduler/executor_test.go`:

Define a `mockBackend` that implements `backend.Backend` interface:
- `Send()` returns a configurable Response or error
- `Close()` returns nil
- `SessionID()` returns "mock-session"

Tests:
1. **Successful execution**: Task with no file locks, mock backend returns success -- task marked completed with result
2. **Failed execution**: Mock backend returns error -- task marked failed with error
3. **File locking**: Task writes ["main.go"], verify LockAll/UnlockAll are called (use a wrapper that records calls)
4. **Unknown agent role**: Task references unregistered role -- returns error
5. **Not eligible**: Try to execute a task that's still pending (has unresolved deps) -- returns error
6. **Context cancellation**: Cancel context before Send -- task marked failed

Note: The mock backend in this test file is local to the scheduler package tests. It wraps the backend.Backend interface for testing purposes.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go test ./internal/scheduler/ -v -count=1 -race` -- all tests pass including new executor tests.
  </verify>
  <done>
Executor dispatches tasks to backends with resource locking and DAG status updates. Mock backend enables isolated testing. All tests pass including context cancellation and error handling paths.
  </done>
</task>

</tasks>

<verification>
- `go build ./internal/scheduler/` compiles
- `go test ./internal/scheduler/ -v -count=1 -race` all tests pass
- `go vet ./internal/scheduler/` no issues
- ResourceLockManager prevents concurrent same-file writes
- Executor correctly bridges DAG tasks to backends
</verification>

<success_criteria>
- Per-file locks allow concurrent writes to different files
- LockAll sorts lexicographically before acquiring (prevents deadlocks)
- Executor acquires locks before backend.Send, releases after (even on error)
- Task status in DAG is updated correctly for success, failure, and cancellation
- All tests pass under -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-definitions-and-dag-scheduler/02-03-SUMMARY.md`
</output>
