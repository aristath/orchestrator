---
phase: 02-agent-definitions-and-dag-scheduler
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/scheduler/task.go
  - internal/scheduler/dag.go
  - internal/scheduler/dag_test.go
autonomous: true

must_haves:
  truths:
    - "Orchestrator decomposes a plan into a DAG where each node is a task and edges represent dependencies"
    - "DAG rejects circular dependencies at construction time with a clear error message identifying the cycle"
    - "Tasks with no unresolved dependencies are marked eligible for execution"
    - "Completing a task triggers downstream dependency resolution"
  artifacts:
    - path: "internal/scheduler/task.go"
      provides: "Task struct with ID, dependencies, status, failure mode, file writes"
      contains: "type Task struct"
    - path: "internal/scheduler/dag.go"
      provides: "DAG construction, cycle detection via topological sort, dependency resolution"
      contains: "func NewDAG"
    - path: "internal/scheduler/dag_test.go"
      provides: "Table-driven tests for DAG validation and dependency resolution"
      contains: "func TestDAG"
  key_links:
    - from: "internal/scheduler/dag.go"
      to: "internal/scheduler/task.go"
      via: "DAG stores and manages Task nodes"
      pattern: "tasks.*map\\[string\\]\\*Task"
    - from: "internal/scheduler/dag.go"
      to: "github.com/gammazero/toposort"
      via: "Kahn's algorithm for cycle detection"
      pattern: "toposort\\.Toposort"
---

<objective>
DAG scheduler core: task types, graph construction, topological sort with cycle detection, and dependency resolution.

Purpose: The DAG is the central scheduling data structure. Tasks are nodes, dependencies are edges. This plan builds the graph, validates it (rejecting cycles), and implements the dependency resolution logic that marks tasks eligible when their dependencies complete.

Output: `internal/scheduler/` package with task types, DAG, and comprehensive tests.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agent-definitions-and-dag-scheduler/02-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Task types and DAG with cycle detection</name>
  <files>internal/scheduler/task.go, internal/scheduler/dag.go</files>
  <action>
First, install the toposort dependency:
```bash
cd /Users/aristath/orchestrator && go get github.com/gammazero/toposort@v0.1.1
```

Create `internal/scheduler/task.go`:

```go
// TaskStatus represents the current state of a task.
type TaskStatus int

const (
    TaskPending   TaskStatus = iota // Waiting for dependencies
    TaskEligible                     // All dependencies resolved, ready to run
    TaskRunning                      // Currently executing
    TaskCompleted                    // Finished successfully
    TaskFailed                       // Finished with error
    TaskSkipped                      // Intentionally not run
)

// FailureMode determines how a task's failure affects dependents.
type FailureMode int

const (
    FailHard FailureMode = iota // Block ALL dependents
    FailSoft                     // Dependents CAN still run
    FailSkip                     // Treat as success for dependency purposes
)

// Task represents a unit of work in the DAG.
type Task struct {
    ID          string      // Unique identifier
    Name        string      // Human-readable name
    AgentRole   string      // Key into config.Agents map (e.g., "coder", "reviewer")
    Prompt      string      // The prompt/instruction for the agent
    DependsOn   []string    // Task IDs this task depends on
    WritesFiles []string    // Files this task will write (for resource locking)
    Status      TaskStatus
    FailureMode FailureMode
    Result      string      // Output from execution (populated after completion)
    Error       error       // Error if failed
}
```

Create `internal/scheduler/dag.go`:

Implement a `DAG` struct with these methods:

- `NewDAG() *DAG` -- creates empty DAG
- `AddTask(task *Task) error` -- adds a task to the DAG. Returns error if task ID already exists.
- `Validate() ([]string, error)` -- runs topological sort using `gammazero/toposort`. Returns ordered task IDs or error if cycle detected. The error message MUST identify which tasks are in the cycle. Also verifies all task IDs in DependsOn actually exist in the DAG (returns error for missing dependencies). After sort, verify sorted result contains ALL task IDs (catches disconnected components per research pitfall #1).
- `Eligible() []*Task` -- returns all tasks with status TaskPending whose dependencies are ALL completed (or skipped/soft-failed per FailureMode). Does NOT include tasks already eligible/running/completed/failed.
- `MarkRunning(taskID string) error` -- sets task status to TaskRunning
- `MarkCompleted(taskID string, result string) error` -- sets task status to TaskCompleted, stores result, then recalculates eligible tasks
- `MarkFailed(taskID string, err error) error` -- sets task status to TaskFailed, stores error. If FailureMode is FailHard, dependents stay pending forever. If FailSoft, dependents can become eligible. If FailSkip, treat as completed for dependency resolution.
- `Get(taskID string) (*Task, bool)` -- returns task by ID
- `Tasks() []*Task` -- returns all tasks
- `Order() ([]string, error)` -- returns topologically sorted task IDs (calls Validate)

For the `Eligible()` method, when checking if a dependency is "resolved":
- TaskCompleted -> resolved
- TaskSkipped -> resolved
- TaskFailed with FailSoft -> resolved (dependents can run)
- TaskFailed with FailSkip -> resolved (treat as success)
- TaskFailed with FailHard -> NOT resolved (blocks dependents)
- Everything else -> NOT resolved

Internal state: `tasks map[string]*Task` for storage, plus `dependents map[string][]string` (maps taskID -> list of task IDs that depend on it) for efficient downstream lookup.
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go build ./internal/scheduler/` -- must compile without errors.
  </verify>
  <done>
task.go defines Task with Status, FailureMode, dependencies, and file writes. dag.go implements DAG with AddTask, Validate (topological sort + cycle detection via gammazero/toposort), Eligible (dependency resolution with failure mode awareness), MarkRunning/Completed/Failed. Both compile.
  </done>
</task>

<task type="auto">
  <name>Task 2: DAG table-driven tests</name>
  <files>internal/scheduler/dag_test.go</files>
  <action>
Create `internal/scheduler/dag_test.go` with comprehensive table-driven tests:

**Validation tests (TestDAGValidate):**
1. "valid linear chain" -- A -> B -> C, no error, order respects dependencies
2. "valid parallel tasks" -- A and B independent, C depends on both, no error
3. "single task no deps" -- one task, no error
4. "direct cycle" -- A depends on B, B depends on A, error containing "cycle"
5. "transitive cycle" -- A->B->C->A, error containing "cycle"
6. "self-loop" -- A depends on A, error containing "cycle"
7. "missing dependency" -- A depends on "nonexistent", error containing "nonexistent"
8. "duplicate task ID" -- adding same ID twice returns error
9. "disconnected components" -- A->B and C->D (no connection), all 4 in sorted result

**Eligibility tests (TestDAGEligible):**
1. "initial eligible" -- tasks with no deps are eligible after Validate
2. "completion unlocks dependents" -- complete A, B (depends on A) becomes eligible
3. "partial completion" -- C depends on A and B, complete only A, C still not eligible
4. "hard failure blocks" -- A fails with FailHard, B (depends on A) never eligible
5. "soft failure allows" -- A fails with FailSoft, B (depends on A) becomes eligible
6. "skip treated as success" -- A fails with FailSkip, B (depends on A) becomes eligible

**State transition tests (TestDAGMarkTransitions):**
1. MarkRunning on eligible task succeeds
2. MarkCompleted stores result
3. MarkFailed stores error
4. MarkRunning on non-existent task returns error

For each test: create DAG, add tasks, call Validate(), then exercise the specific behavior. Use `t.Run` for subtests. Assert exact expected values, not just "no error."
  </action>
  <verify>
Run `cd /Users/aristath/orchestrator && go test ./internal/scheduler/ -v -count=1 -race` -- all tests pass with no data races.
  </verify>
  <done>
dag_test.go has 15+ test cases covering validation (cycle detection, missing deps, disconnected graphs), eligibility (dependency resolution with all three failure modes), and state transitions. All pass with -race flag.
  </done>
</task>

</tasks>

<verification>
- `go build ./internal/scheduler/` compiles
- `go test ./internal/scheduler/ -v -count=1 -race` all tests pass
- `go vet ./internal/scheduler/` no issues
- Cycle detection identifies the cycle participants in error message
- Disconnected DAG components are all included in sorted output
</verification>

<success_criteria>
- DAG.Validate() detects direct cycles, transitive cycles, and self-loops with clear error messages
- DAG.Eligible() correctly resolves dependencies considering FailHard/FailSoft/FailSkip
- Missing dependency references are caught at validation time
- Disconnected components are not lost during topological sort
- All tests pass under -race flag
</success_criteria>

<output>
After completion, create `.planning/phases/02-agent-definitions-and-dag-scheduler/02-02-SUMMARY.md`
</output>
