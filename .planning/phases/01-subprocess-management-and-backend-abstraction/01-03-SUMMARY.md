---
phase: 01-subprocess-management-and-backend-abstraction
plan: 03
subsystem: backend-adapters
tags: [codex-adapter, openai, cli-subprocess, event-stream-json, thread-management]
dependency_graph:
  requires:
    - backend.Backend interface (01-01)
    - newCommand and executeCommand utilities (01-01)
    - ProcessManager (01-01)
  provides:
    - CodexAdapter implementation
    - Codex event stream parser
    - Thread ID management for multi-turn conversations
  affects:
    - Backend factory (codex case now functional)
    - Future integration tests (01-05)
tech_stack:
  added:
    - Codex CLI subprocess invocation
    - Newline-delimited JSON event parsing
    - Thread ID extraction from ThreadStarted events
  patterns:
    - Event stream parsing with bufio.Scanner
    - First message vs resume command construction
    - Thread ID capture and session management
key_files:
  created:
    - internal/backend/codex.go
    - internal/backend/codex_test.go
  modified:
    - internal/backend/backend.go (codex case)
decisions:
  - decision: "Use codex exec for first message, codex resume <THREAD_ID> for subsequent"
    rationale: "Codex CLI design separates starting new threads from resuming existing ones"
    impact: "Adapter tracks started state and builds appropriate command structure"
  - decision: "Parse newline-delimited JSON with bufio.Scanner"
    rationale: "Codex outputs event stream as one JSON object per line"
    impact: "Simple line-by-line parsing extracts ThreadStarted and TurnCompleted events"
  - decision: "Store thread ID from first ThreadStarted event"
    rationale: "Thread ID comes from Codex response, not pre-generated by orchestrator"
    impact: "SessionID() returns empty until first message completes"
metrics:
  duration_seconds: 238
  tasks_completed: 2
  files_created: 2
  commits: 2
  completed_date: "2026-02-10"
---

# Phase 01 Plan 03: Codex CLI Adapter Summary

**One-liner:** OpenAI Codex CLI adapter with newline-delimited JSON event parsing, thread ID management for multi-turn conversations, and exec/resume command construction.

## Plan Overview

**Objective:** Implement the Codex CLI adapter that can start threads, send prompts, receive newline-delimited JSON events, and resume conversations.

**Outcome:** Successfully implemented CodexAdapter with complete test coverage. All adapters (Claude, Codex, Goose) now implement the Backend interface and are wired into the factory.

## Tasks Completed

### Task 1: Implement Codex adapter
**Status:** ✓ Complete
**Commit:** a49b7c4
**Files:** internal/backend/codex.go, internal/backend/backend.go

- Created `CodexAdapter` struct with:
  - `threadID` - thread ID for resuming conversations (extracted from ThreadStarted event)
  - `workDir` - working directory for CLI execution
  - `model` - optional model override (appends `--model` flag)
  - `started` - tracks whether first message has been sent
  - `procMgr` - reference to ProcessManager for subprocess tracking
- Implemented `NewCodexAdapter()`:
  - Uses cfg.SessionID as initial threadID if provided (for resuming)
  - Sets started=true if SessionID exists
- Implemented `Send()`:
  - First message: builds `["exec", prompt, "--json"]`
  - Subsequent messages: builds `["resume", threadID, "--json"]`
  - Adds `["--model", model]` if configured
  - Executes command via `newCommand()` and `executeCommand()`
  - Parses response via `parseCodexEvents()`
  - Extracts and stores threadID from ThreadStarted event
  - Returns Response with content and sessionID
- Implemented `buildArgs()` - testable command construction
- Implemented `parseCodexEvents()`:
  - Parses newline-delimited JSON with bufio.Scanner
  - Extracts thread_id from ThreadStarted events
  - Extracts content from TurnCompleted events
  - Returns error for malformed JSON
- Implemented `Close()` - no-op (per-invocation subprocess)
- Implemented `SessionID()` - returns threadID
- Updated backend factory to wire up CodexAdapter for type "codex"

### Task 2: Add Codex adapter unit tests
**Status:** ✓ Complete
**Commit:** 15af0a8
**Files:** internal/backend/codex_test.go

- `TestNewCodexAdapter_NoInitialThreadID` - verifies new adapter starts without thread ID
- `TestNewCodexAdapter_UsesProvidedThreadID` - verifies provided SessionID is used and started=true
- `TestCodexAdapter_BuildsFirstExecCommand` - verifies first Send builds exec command with prompt and --json
- `TestCodexAdapter_BuildsResumeCommand` - verifies resume command with thread ID after started=true
- `TestCodexAdapter_IncludesModel` - verifies --model flag appears when configured
- `TestCodexAdapter_ParsesEventStream` - verifies parsing ThreadStarted and TurnCompleted from sample JSON
- `TestCodexAdapter_ParsesEmptyEvents` - verifies empty input returns empty content without error
- `TestCodexAdapter_ParsesMalformedJSON` - verifies error for invalid JSON line
- `TestCodexAdapter_ExtractsThreadIDFromResponse` - verifies thread ID stored after parsing and used in subsequent buildArgs
- `TestCodexAdapter_Close` - verifies Close returns nil

All 10 tests pass.

## Deviations from Plan

### Auto-fixed Issues

**1. [Rule 3 - Blocking Issue] Fixed executeCommand signature mismatch in goose.go**
- **Found during:** Task 1 build verification
- **Issue:** goose.go was calling `executeCommand(ctx, cmd)` but signature requires `executeCommand(ctx, cmd, pm *ProcessManager)`
- **Fix:** Updated goose.go line 66 to pass `g.procMgr` parameter
- **Files modified:** internal/backend/goose.go
- **Commit:** Not separately committed (pre-existing file from different execution)
- **Rationale:** executeCommand was updated in 01-01 to accept ProcessManager for subprocess tracking. Goose adapter was implemented before this change was merged, causing a build failure that blocked Task 1 verification.

## Technical Decisions

### 1. Command Construction Pattern: exec vs resume
**Context:** Codex CLI has separate commands for starting new threads and resuming existing ones.

**Decision:** Use `codex exec <prompt> --json` for first message, `codex resume <THREAD_ID> --json` for subsequent messages.

**Rationale:** This matches Codex CLI semantics where:
- `exec` starts a new thread and accepts a prompt as an argument
- `resume` continues an existing thread by ID

**Implementation:** Track `started` boolean and check `threadID` to determine which command to build. Extract `buildArgs()` into testable method.

**Impact:** Clean separation between first-time and resumption logic. Tests can verify command construction independently.

### 2. Thread ID Management
**Context:** Codex generates thread IDs server-side, not client-side.

**Decision:** Leave threadID empty until first response. Extract thread_id from ThreadStarted event in response JSON.

**Rationale:** ThreadStarted event contains `{"type":"ThreadStarted","thread_id":"thread_abc123"}`. Trying to pre-generate a thread ID client-side would not match Codex's server-side ID.

**Implementation:** `SessionID()` returns empty string until first `Send()` completes. Parse ThreadStarted event and store thread_id for future resume calls.

**Impact:** Orchestrator must handle backends where SessionID is not known until first message. This matches real-world CLI behavior.

### 3. Event Stream Parsing with bufio.Scanner
**Context:** Codex outputs newline-delimited JSON events (one JSON object per line).

**Decision:** Use `bufio.Scanner` to read line-by-line, unmarshal each line to check event type, then unmarshal again into specific event structs.

**Rationale:** Scanner handles newline splitting cleanly. Two-pass unmarshal (first for type, then for full struct) keeps code simple and extensible for new event types.

**Implementation:**
```go
scanner := bufio.Scanner(bytes.NewReader(data))
for scanner.Scan() {
    var evt codexEvent
    json.Unmarshal(line, &evt)
    switch evt.Type {
    case "ThreadStarted": // unmarshal into codexThreadStarted
    case "TurnCompleted": // unmarshal into codexTurnCompleted
    }
}
```

**Impact:** Easy to add new event types. Clear error handling for malformed JSON. Works with arbitrarily large event streams.

## Verification Results

✓ `go build ./...` - compiles cleanly
✓ `go vet ./...` - no warnings
✓ `go test ./internal/backend/ -v -run TestCodex` - all 10 tests pass
✓ CodexAdapter implements Backend interface (compile-time check)
✓ New("codex", cfg, pm) returns CodexAdapter
✓ buildArgs produces correct command structure for exec vs resume
✓ parseCodexEvents extracts thread_id from ThreadStarted and content from TurnCompleted
✓ Event parser handles empty input and malformed JSON

## Next Steps

This plan completes the Codex adapter implementation. All three backend adapters (Claude, Codex, Goose) are now implemented:

1. **Plan 01-01:** ✓ Backend interface and subprocess utilities
2. **Plan 01-02:** ✓ Claude Code adapter (already completed)
3. **Plan 01-03:** ✓ Codex adapter (this plan)
4. **Plan 01-04:** ✓ Goose adapter (already completed)
5. **Plan 01-05:** Integration tests to verify all adapters work end-to-end

The backend abstraction layer is now complete. Integration tests will verify that all adapters:
- Can execute commands via subprocess
- Are tracked by ProcessManager
- Parse their respective CLI output formats
- Handle errors gracefully
- Clean up on Close()

## Self-Check: PASSED

All claimed artifacts verified:

```bash
# Files exist
$ ls internal/backend/codex.go internal/backend/codex_test.go
internal/backend/codex.go
internal/backend/codex_test.go

# Commits exist
$ git log --oneline | grep -E "a49b7c4|15af0a8"
a49b7c4 feat(01-03): implement Codex CLI adapter
15af0a8 test(01-03): add Codex adapter unit tests

# Tests pass
$ go test ./internal/backend/ -v -run TestCodex
... PASS (all 10 tests)

# Build succeeds
$ go build ./...
(no output = success)
```

✓ internal/backend/codex.go - created
✓ internal/backend/codex_test.go - created
✓ internal/backend/backend.go - modified (codex case added)
✓ Commit a49b7c4 - implementation
✓ Commit 15af0a8 - tests
✓ All tests pass
✓ Project compiles
