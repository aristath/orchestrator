---
phase: 01-subprocess-management-and-backend-abstraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - internal/backend/backend.go
  - internal/backend/process.go
  - internal/backend/types.go
autonomous: true

must_haves:
  truths:
    - "A Backend interface exists with Send and Close methods"
    - "Message and Response types are defined with Content, SessionID, and Error fields"
    - "Subprocess pipes are read concurrently via goroutines before cmd.Wait()"
    - "Process groups are configured with Setpgid:true for signal propagation"
    - "ProcessManager tracks all running subprocesses and can kill them all on shutdown"
    - "cmd.Wait() is always called after subprocess completes"
  artifacts:
    - path: "go.mod"
      provides: "Go module definition"
      contains: "module github.com/aristath/orchestrator"
    - path: "internal/backend/backend.go"
      provides: "Backend interface and factory function"
      exports: ["Backend", "Config", "New"]
    - path: "internal/backend/types.go"
      provides: "Message, Response, and shared type definitions"
      exports: ["Message", "Response"]
    - path: "internal/backend/process.go"
      provides: "Subprocess utilities: concurrent pipe reading, process groups, ProcessManager"
      exports: ["ProcessManager", "NewProcessManager", "executeCommand"]
  key_links:
    - from: "internal/backend/backend.go"
      to: "internal/backend/types.go"
      via: "Message and Response types used in interface"
      pattern: "Send.*Message.*Response"
    - from: "internal/backend/process.go"
      to: "syscall.SysProcAttr"
      via: "Process group configuration"
      pattern: "Setpgid.*true"
---

<objective>
Set up the Go module, define the Backend interface, shared types, and subprocess management utilities that all adapters will use.

Purpose: Establish the foundational abstraction and subprocess infrastructure that Claude Code, Codex, and Goose adapters will build on. Without this, no adapter can be implemented.
Output: Go module with Backend interface, Message/Response types, concurrent pipe reader, process group management, and ProcessManager for tracking subprocesses.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-subprocess-management-and-backend-abstraction/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and define shared types</name>
  <files>go.mod, internal/backend/types.go</files>
  <action>
1. Initialize Go module:
   ```
   go mod init github.com/aristath/orchestrator
   ```

2. Create `internal/backend/types.go` with:
   - `Message` struct: `Content string`, `Role string` (user/system)
   - `Response` struct: `Content string`, `SessionID string`, `Error string`
   - `Config` struct: `Type string` (claude/codex/goose), `WorkDir string`, `SessionID string`, `Model string`, `Provider string` (for Goose local LLMs), `SystemPrompt string`

Keep types minimal. These are the contract between the Backend interface and all adapters.
  </action>
  <verify>
Run `go vet ./...` — should pass with no errors. Types are defined and importable.
  </verify>
  <done>
go.mod exists with module path. types.go compiles and exports Message, Response, Config structs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Define Backend interface and subprocess utilities</name>
  <files>internal/backend/backend.go, internal/backend/process.go</files>
  <action>
1. Create `internal/backend/backend.go` with:
   - `Backend` interface with methods:
     - `Send(ctx context.Context, msg Message) (Response, error)` — sends prompt, returns parsed response
     - `Close() error` — terminates subprocess gracefully
     - `SessionID() string` — returns current session identifier
   - `New(cfg Config) (Backend, error)` factory function that switches on `cfg.Type` and returns the appropriate adapter. For now, return `fmt.Errorf("unknown backend type: %s")` for all types since adapters don't exist yet. Add cases for "claude", "codex", "goose" that return the error with a TODO comment — adapter plans will fill these in.

2. Create `internal/backend/process.go` with:
   - `newCommand(ctx context.Context, name string, args ...string) *exec.Cmd` — creates exec.Cmd with `SysProcAttr{Setpgid: true}` for process group isolation.
   - `executeCommand(ctx context.Context, cmd *exec.Cmd) (stdout []byte, stderr []byte, err error)` — the core subprocess execution function that:
     a. Creates stdout and stderr pipes via `cmd.StdoutPipe()` and `cmd.StderrPipe()`
     b. Calls `cmd.Start()`
     c. Reads both pipes concurrently in separate goroutines using `io.Copy` to `bytes.Buffer`, synchronized with `sync.WaitGroup`
     d. Calls `wg.Wait()` to ensure both pipe readers complete
     e. Calls `cmd.Wait()` to collect exit status (MUST happen after pipe readers complete)
     f. Returns stdout bytes, stderr bytes, and any error (combining wait error with stderr context)
   - `killProcessGroup(cmd *exec.Cmd) error` — kills entire process group via `syscall.Kill(-cmd.Process.Pid, syscall.SIGKILL)`. Check `cmd.Process != nil` before calling.
   - `ProcessManager` struct with:
     - `mu sync.Mutex` and `procs map[int]*exec.Cmd` fields
     - `NewProcessManager() *ProcessManager` constructor
     - `Track(cmd *exec.Cmd)` — adds subprocess PID to tracked map (after Start, when Process is non-nil)
     - `Untrack(cmd *exec.Cmd)` — removes subprocess from tracked map (after Wait completes)
     - `KillAll() error` — iterates all tracked subprocesses and calls `killProcessGroup` on each. Collects errors. Used during shutdown.
     - `Count() int` — returns number of currently tracked processes (useful for tests)

Important implementation notes:
- `executeCommand` must read pipes BEFORE calling `cmd.Wait()` — this is the deadlock prevention pattern (BACK-05)
- `Setpgid: true` in `newCommand` is the process group isolation (BACK-06)
- `ProcessManager.KillAll()` + always calling `cmd.Wait()` via `executeCommand` covers zombie prevention (BACK-07)
- Use `signal.NotifyContext` pattern in comments/doc to show how orchestrator main will use this (but don't implement main yet)
  </action>
  <verify>
Run `go vet ./...` and `go build ./...` — both should pass. Verify:
- `Backend` interface has Send, Close, SessionID methods
- `executeCommand` creates pipes, starts goroutines, calls wg.Wait then cmd.Wait
- `newCommand` sets Setpgid: true
- `ProcessManager` has Track, Untrack, KillAll, Count methods
  </verify>
  <done>
Backend interface is defined and compilable. executeCommand implements concurrent pipe reading pattern. newCommand configures process groups. ProcessManager tracks subprocesses for cleanup. `go build ./...` succeeds.
  </done>
</task>

</tasks>

<verification>
- `go mod tidy && go vet ./... && go build ./...` all pass
- Backend interface has Send(ctx, Message) (Response, error), Close() error, SessionID() string
- executeCommand reads stdout/stderr concurrently before cmd.Wait()
- newCommand sets SysProcAttr with Setpgid: true
- ProcessManager can Track, Untrack, KillAll, and report Count
- New() factory exists with placeholder cases for claude, codex, goose
</verification>

<success_criteria>
Go module compiles cleanly. Backend interface, shared types, and subprocess utilities are defined and ready for adapter implementations. The concurrent pipe reading pattern, process group configuration, and ProcessManager are all implemented and compilable.
</success_criteria>

<output>
After completion, create `.planning/phases/01-subprocess-management-and-backend-abstraction/01-01-SUMMARY.md`
</output>
