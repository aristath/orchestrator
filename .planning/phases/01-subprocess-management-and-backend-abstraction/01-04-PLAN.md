---
phase: 01-subprocess-management-and-backend-abstraction
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/backend/goose.go
  - internal/backend/goose_test.go
  - internal/backend/backend.go
autonomous: true

must_haves:
  truths:
    - "Goose adapter can build the correct CLI command with run and --output-format json"
    - "Goose adapter can parse JSON response into Response struct"
    - "Goose adapter can start a new session with --name"
    - "Goose adapter can resume a session with --resume"
    - "Goose adapter passes --provider and --model for local LLM support"
    - "Goose adapter passes --system for custom system instructions"
  artifacts:
    - path: "internal/backend/goose.go"
      provides: "Goose CLI adapter implementation with local LLM support"
      exports: ["GooseAdapter", "NewGooseAdapter"]
    - path: "internal/backend/goose_test.go"
      provides: "Unit tests for Goose adapter"
      contains: "TestGoose"
  key_links:
    - from: "internal/backend/goose.go"
      to: "internal/backend/backend.go"
      via: "Implements Backend interface"
      pattern: "func.*GooseAdapter.*Send"
    - from: "internal/backend/goose.go"
      to: "internal/backend/process.go"
      via: "Uses newCommand and executeCommand"
      pattern: "newCommand|executeCommand"
    - from: "internal/backend/backend.go"
      to: "internal/backend/goose.go"
      via: "Factory creates GooseAdapter"
      pattern: "NewGooseAdapter"
---

<objective>
Implement the Goose CLI adapter that can start sessions, send prompts, receive JSON responses, resume conversations, and configure local LLM providers.

Purpose: Goose is the local LLM backend, enabling use of Ollama, LM Studio, and llama.cpp. This adapter translates Backend.Send() calls into `goose run` CLI invocations with provider/model configuration.
Output: Working GooseAdapter with local LLM support and unit tests, wired into the Backend factory.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-subprocess-management-and-backend-abstraction/01-RESEARCH.md
@.planning/phases/01-subprocess-management-and-backend-abstraction/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Goose adapter with local LLM support</name>
  <files>internal/backend/goose.go, internal/backend/backend.go</files>
  <action>
1. Create `internal/backend/goose.go` with:

   - `GooseAdapter` struct with fields:
     - `sessionName string` — session name for multi-turn
     - `workDir string` — working directory for the CLI
     - `model string` — model override (e.g., "llama2", "codellama")
     - `provider string` — provider override (e.g., "ollama", "anthropic", "openai")
     - `systemPrompt string` — system instructions
     - `started bool` — tracks whether first message has been sent
     - `procMgr *ProcessManager` — reference to shared process manager

   - `NewGooseAdapter(cfg Config, procMgr *ProcessManager) (*GooseAdapter, error)`:
     - If `cfg.SessionID` is empty, generate a session name using format "orchestrator-{random-hex}" (Goose uses names, not UUIDs)
     - Set workDir, model, provider, systemPrompt from cfg
     - Return configured adapter

   - `Send(ctx context.Context, msg Message) (Response, error)`:
     - Build base args: `["run", "--text", msg.Content, "--output-format", "json"]`
     - If first message (`!started`): append `"--name", sessionName`
     - If resuming (`started`): append `"--resume"`
       Note: Goose --resume resumes from the previous session. If --name was used on first run, subsequent --resume picks up that session. Verify this assumption during integration testing (Plan 05).
     - If `provider` is set: append `"--provider", provider`
     - If `model` is set: append `"--model", model`
     - If `systemPrompt` is set: append `"--system", systemPrompt`
     - Create command via `newCommand(ctx, "goose", args...)`
     - Set `cmd.Dir = workDir`
     - Execute via `executeCommand(ctx, cmd, procMgr)`
     - Parse JSON response from stdout:
       Goose JSON output structure is less documented. Define a flexible `gooseResponse` struct:
       ```go
       type gooseResponse struct {
           Content string `json:"content"`
           // Add fields as discovered during integration testing
       }
       ```
       Parse function `parseGooseResponse(data []byte) (Response, error)`:
       - Try parsing as single JSON object first
       - If that fails, try newline-delimited JSON (stream-json format) — use same line-by-line approach as Codex
       - Extract text content from whatever structure Goose returns
       - If `--output-format json` is not supported (see research note about GitHub issue #4419), fall back to treating entire stdout as plain text content
     - Set `started = true`
     - Return Response with Content and SessionID (sessionName)

   - `Close() error`: No-op (per-invocation subprocess). Return nil.

   - `SessionID() string`: Return `sessionName`

   - `buildArgs(msg Message) []string`: Extract command construction into testable method.

2. Update `internal/backend/backend.go`:
   - In `New()` factory, wire up: `case "goose": return NewGooseAdapter(cfg, pm)`

**Important — Local LLM support (BACK-04 requirement):**
The `--provider` and `--model` flags are the mechanism for local LLM support:
- Ollama: `--provider ollama --model llama2`
- LM Studio: `--provider lmstudio --model <model-name>`
- llama.cpp: `--provider llamacpp --model <model-path>`
These are simply passed through to the Goose CLI which handles the actual LLM communication. The adapter's job is just to include these flags when configured.
  </action>
  <verify>
`go build ./...` passes. `go vet ./...` passes. GooseAdapter implements Backend interface. New("goose", ...) returns a GooseAdapter.
  </verify>
  <done>
GooseAdapter implements Backend interface. Builds correct `goose run` command with --name (first call), --resume (subsequent calls), --output-format json, --provider, --model, and --system flags. Supports local LLM configuration via provider/model passthrough. Factory function wired up.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Goose adapter unit tests</name>
  <files>internal/backend/goose_test.go</files>
  <action>
Create `internal/backend/goose_test.go` with tests:

1. `TestNewGooseAdapter_GeneratesSessionName`: Create adapter with empty SessionID. Verify SessionID() returns a string matching "orchestrator-" prefix with hex suffix.

2. `TestNewGooseAdapter_UsesProvidedSessionName`: Create adapter with specific SessionID. Verify SessionID() returns that exact name.

3. `TestGooseAdapter_BuildsFirstRunCommand`: Test that first Send builds args with `--name`. Verify args contain: `run`, `--text`, prompt, `--output-format`, `json`, `--name`, session name. Verify args do NOT contain `--resume`.

4. `TestGooseAdapter_BuildsResumeCommand`: Test that after marking as started, args use `--resume`. Verify args contain: `--resume`. Verify args do NOT contain `--name`.

5. `TestGooseAdapter_IncludesProvider`: Test that when provider is "ollama", `--provider ollama` appears in args.

6. `TestGooseAdapter_IncludesModel`: Test that when model is "llama2", `--model llama2` appears in args.

7. `TestGooseAdapter_IncludesSystemPrompt`: Test that when systemPrompt is set, `--system` appears in args.

8. `TestGooseAdapter_LocalLLMConfig`: Test the full local LLM scenario: provider="ollama", model="codellama". Verify both `--provider ollama` and `--model codellama` appear in args.

9. `TestGooseAdapter_ParsesJSONResponse`: Test JSON parsing with a sample response:
   ```json
   {"content": "Hello from Goose"}
   ```
   Verify Response.Content = "Hello from Goose".

10. `TestGooseAdapter_ParsesPlainTextFallback`: Test that if JSON parsing fails, the raw stdout is used as content (fallback for when --output-format json is not supported).

11. `TestGooseAdapter_Close`: Verify Close() returns nil.
  </action>
  <verify>
`go test ./internal/backend/ -v -run TestGoose` — all tests pass.
  </verify>
  <done>
All Goose adapter unit tests pass. Command construction produces correct flags for new session vs resume. Local LLM configuration (provider + model) is correctly passed through. JSON parsing works with fallback to plain text.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/backend/ -v -run TestGoose` — all tests pass
- `go build ./...` — compiles cleanly
- GooseAdapter satisfies Backend interface (compile-time check)
- buildArgs includes --provider and --model when configured (local LLM support)
- JSON parser handles Goose response format with plain text fallback
</verification>

<success_criteria>
Goose adapter fully implements Backend interface with local LLM support via --provider/--model passthrough. Unit tests verify command construction (--name vs --resume, --provider, --model, --system, --output-format json) and JSON response parsing with fallback. Factory function creates GooseAdapter for type "goose".
</success_criteria>

<output>
After completion, create `.planning/phases/01-subprocess-management-and-backend-abstraction/01-04-SUMMARY.md`
</output>
