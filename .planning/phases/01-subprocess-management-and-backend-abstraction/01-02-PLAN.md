---
phase: 01-subprocess-management-and-backend-abstraction
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/backend/claude.go
  - internal/backend/claude_test.go
  - internal/backend/backend.go
autonomous: true

must_haves:
  truths:
    - "Claude Code adapter can build the correct CLI command with all required flags"
    - "Claude Code adapter can parse JSON response into Response struct"
    - "Claude Code adapter can start a new session with --session-id"
    - "Claude Code adapter can resume a session with --resume"
    - "Claude Code adapter passes --system-prompt when configured"
    - "Claude Code adapter uses --output-format json for structured output"
  artifacts:
    - path: "internal/backend/claude.go"
      provides: "Claude Code CLI adapter implementation"
      exports: ["ClaudeAdapter", "NewClaudeAdapter"]
    - path: "internal/backend/claude_test.go"
      provides: "Unit tests for Claude Code adapter"
      contains: "TestClaude"
  key_links:
    - from: "internal/backend/claude.go"
      to: "internal/backend/backend.go"
      via: "Implements Backend interface"
      pattern: "func.*ClaudeAdapter.*Send"
    - from: "internal/backend/claude.go"
      to: "internal/backend/process.go"
      via: "Uses newCommand and executeCommand"
      pattern: "newCommand|executeCommand"
    - from: "internal/backend/backend.go"
      to: "internal/backend/claude.go"
      via: "Factory creates ClaudeAdapter"
      pattern: "NewClaudeAdapter"
---

<objective>
Implement the Claude Code CLI adapter that can start sessions, send prompts, receive JSON responses, and resume conversations.

Purpose: Claude Code is the primary backend. This adapter translates Backend.Send() calls into `claude` CLI invocations with the correct flags and parses the JSON response.
Output: Working ClaudeAdapter with unit tests, wired into the Backend factory.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-subprocess-management-and-backend-abstraction/01-RESEARCH.md
@.planning/phases/01-subprocess-management-and-backend-abstraction/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Claude Code adapter</name>
  <files>internal/backend/claude.go, internal/backend/backend.go</files>
  <action>
1. Create `internal/backend/claude.go` with:

   - `ClaudeAdapter` struct with fields:
     - `sessionID string` — UUID for session management
     - `workDir string` — working directory for the CLI
     - `model string` — model override (optional)
     - `systemPrompt string` — system prompt override (optional)
     - `started bool` — tracks whether first message has been sent (determines --session-id vs --resume)
     - `procMgr *ProcessManager` — reference to shared process manager

   - `NewClaudeAdapter(cfg Config, procMgr *ProcessManager) (*ClaudeAdapter, error)`:
     - If `cfg.SessionID` is empty, generate a UUID using `crypto/rand` (format: 8-4-4-4-12 hex)
     - Set workDir from cfg.WorkDir (default to current directory if empty)
     - Store model and systemPrompt from cfg
     - Return configured adapter

   - `Send(ctx context.Context, msg Message) (Response, error)`:
     - Build args slice: `["-p", msg.Content, "--output-format", "json"]`
     - If first message (`!started`): append `"--session-id", sessionID`
     - If resuming (`started`): append `"--resume", sessionID`
     - If `model` is set: append `"--model", model`
     - If `systemPrompt` is set: append `"--system-prompt", systemPrompt`
     - Call `newCommand(ctx, "claude", args...)` to get cmd
     - Set `cmd.Dir = workDir`
     - Call `procMgr.Track(cmd)` after Start (this happens inside executeCommand — so track BEFORE execute, untrack AFTER)
     - Actually, better pattern: call `executeCommand(ctx, cmd)` which handles Start/Wait. Track cmd before executeCommand, untrack after.
     - Wait — executeCommand calls cmd.Start() internally. So: create cmd, then pass to a wrapper that tracks, executes, untracks. Add a method `ExecuteTracked(ctx, cmd) ([]byte, []byte, error)` to ProcessManager that does Track + executeCommand + Untrack. Or keep it simple: have the adapter call executeCommand and manually track/untrack around it. Let's use the simple approach:
       ```
       cmd := newCommand(ctx, "claude", args...)
       cmd.Dir = a.workDir
       // executeCommand handles Start + pipe reading + Wait
       stdout, stderr, err := executeCommand(ctx, cmd)
       ```
       Note: executeCommand calls cmd.Start() internally, so we can't Track before Start. Instead, modify executeCommand to accept an optional ProcessManager, or have the adapter handle tracking. Simplest: have executeCommand return after Start but before Wait... no, that breaks the pattern.

       Best approach: Have ProcessManager provide an `Execute(ctx, cmd) ([]byte, []byte, error)` method that wraps executeCommand with tracking. The ProcessManager calls cmd.Start (from within executeCommand), then tracks via the PID, then reads pipes, then waits, then untracks. Actually executeCommand is a standalone function. Let's just have the adapter use executeCommand directly — the ProcessManager tracking is for long-running subprocesses that might outlive the call. Since executeCommand is synchronous (blocks until subprocess exits), zombie prevention is already handled by the fact that cmd.Wait() is always called inside executeCommand. ProcessManager.Track/KillAll is for the scenario where the orchestrator is killed mid-execution (Ctrl+C) and we need to kill subprocesses that are currently running. So tracking should happen after cmd.Start() but before cmd.Wait(). This means executeCommand needs to accept a ProcessManager or we need to restructure.

       **Resolution:** Modify `executeCommand` signature to accept an optional `*ProcessManager`. If non-nil, Track after Start, defer Untrack. This keeps the pattern clean:
       ```go
       func executeCommand(ctx context.Context, cmd *exec.Cmd, pm *ProcessManager) ([]byte, []byte, error)
       ```
       Inside executeCommand, after `cmd.Start()`:
       ```go
       if pm != nil {
           pm.Track(cmd)
           defer pm.Untrack(cmd)
       }
       ```

     - Parse stdout JSON into Claude-specific response structure, then map to Response:
       Claude Code JSON output has structure:
       ```json
       {"session_id": "...", "result": {"content": [{"type": "text", "text": "..."}]}}
       ```
       Define a private `claudeResponse` struct to unmarshal this, then extract text content.
     - Set `started = true` after successful send
     - Return Response with Content (extracted text), SessionID, and Error if any

   - `Close() error`: No-op for Claude Code (subprocess is per-invocation, not long-running). Return nil.

   - `SessionID() string`: Return `sessionID`

2. Update `internal/backend/backend.go`:
   - In `New()` factory, replace the "claude" case with: `return NewClaudeAdapter(cfg, nil)` — passing nil ProcessManager for now (orchestrator will provide one later). Actually, add a `ProcessManager` parameter to `New()`:
     ```go
     func New(cfg Config, pm *ProcessManager) (Backend, error)
     ```
   - Wire up: `case "claude": return NewClaudeAdapter(cfg, pm)`

Note on UUID generation: Use `crypto/rand` to generate v4 UUIDs. Do NOT add a dependency — implement a simple `generateUUID()` function in claude.go (or a shared util). Format: `xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx` where y is 8, 9, a, or b.
  </action>
  <verify>
`go build ./...` passes. `go vet ./...` passes. ClaudeAdapter implements Backend interface (compiler verifies this). New("claude", ...) returns a ClaudeAdapter.
  </verify>
  <done>
ClaudeAdapter implements Backend interface. Builds correct `claude` CLI command with --session-id (first call), --resume (subsequent calls), --output-format json, optional --model and --system-prompt. Parses Claude Code JSON response. Factory function wired up.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Claude Code adapter unit tests</name>
  <files>internal/backend/claude_test.go</files>
  <action>
Create `internal/backend/claude_test.go` with tests:

1. `TestNewClaudeAdapter_GeneratesSessionID`: Create adapter with empty SessionID in config. Verify SessionID() returns a valid UUID format (regex: `^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$`).

2. `TestNewClaudeAdapter_UsesProvidedSessionID`: Create adapter with specific SessionID. Verify SessionID() returns that exact ID.

3. `TestClaudeAdapter_BuildsFirstMessageCommand`: Test that the first Send builds args with `--session-id` (not --resume). This requires testing command construction without actually executing. Approach: extract a `buildArgs(msg Message, isResume bool) []string` method from ClaudeAdapter and test it directly. This is a pure function test — no subprocess needed.
   - Verify args contain: `-p`, message content, `--output-format`, `json`, `--session-id`, session UUID
   - Verify args do NOT contain `--resume`

4. `TestClaudeAdapter_BuildsResumeCommand`: Test that after marking as started, args use `--resume` instead of `--session-id`.
   - Verify args contain: `--resume`, session UUID
   - Verify args do NOT contain `--session-id`

5. `TestClaudeAdapter_IncludesModel`: Test that when model is configured, `--model` appears in args.

6. `TestClaudeAdapter_IncludesSystemPrompt`: Test that when systemPrompt is configured, `--system-prompt` appears in args.

7. `TestClaudeAdapter_ParsesJSONResponse`: Test the JSON parsing logic. Create a `parseClaudeResponse(data []byte) (Response, error)` function (or method) and test it with:
   - Valid JSON matching Claude Code output format: `{"session_id": "test-uuid", "result": {"content": [{"type": "text", "text": "Hello world"}]}}`
   - Verify Response.Content = "Hello world", Response.SessionID = "test-uuid"
   - Invalid JSON returns error
   - Empty content array returns empty string (not error)

8. `TestClaudeAdapter_Close`: Verify Close() returns nil (no-op).

These are unit tests that test command construction and JSON parsing without spawning real subprocesses. Integration tests with real CLI calls belong in Plan 05.
  </action>
  <verify>
`go test ./internal/backend/ -v -run TestClaude` — all tests pass.
  </verify>
  <done>
All Claude adapter unit tests pass. Command construction produces correct flags for first message vs resume. JSON parsing handles valid Claude Code output format. Model and system prompt flags are included when configured.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/backend/ -v -run TestClaude` — all tests pass
- `go build ./...` — compiles cleanly
- ClaudeAdapter satisfies Backend interface (compile-time check)
- buildArgs produces correct flags for new session vs resume
- JSON parser handles Claude Code response format
</verification>

<success_criteria>
Claude Code adapter fully implements Backend interface. Unit tests verify command construction (--session-id vs --resume, --model, --system-prompt, --output-format json) and JSON response parsing. Factory function creates ClaudeAdapter for type "claude".
</success_criteria>

<output>
After completion, create `.planning/phases/01-subprocess-management-and-backend-abstraction/01-02-SUMMARY.md`
</output>
