---
phase: 01-subprocess-management-and-backend-abstraction
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/backend/codex.go
  - internal/backend/codex_test.go
  - internal/backend/backend.go
autonomous: true

must_haves:
  truths:
    - "Codex adapter can build the correct CLI command with exec and --json flags"
    - "Codex adapter can parse newline-delimited JSON events into Response struct"
    - "Codex adapter can start a new thread with codex exec"
    - "Codex adapter can resume a thread with codex resume <THREAD_ID>"
    - "Codex adapter extracts thread_id from ThreadStarted event for session management"
  artifacts:
    - path: "internal/backend/codex.go"
      provides: "Codex CLI adapter implementation"
      exports: ["CodexAdapter", "NewCodexAdapter"]
    - path: "internal/backend/codex_test.go"
      provides: "Unit tests for Codex adapter"
      contains: "TestCodex"
  key_links:
    - from: "internal/backend/codex.go"
      to: "internal/backend/backend.go"
      via: "Implements Backend interface"
      pattern: "func.*CodexAdapter.*Send"
    - from: "internal/backend/codex.go"
      to: "internal/backend/process.go"
      via: "Uses newCommand and executeCommand"
      pattern: "newCommand|executeCommand"
    - from: "internal/backend/backend.go"
      to: "internal/backend/codex.go"
      via: "Factory creates CodexAdapter"
      pattern: "NewCodexAdapter"
---

<objective>
Implement the Codex CLI adapter that can start threads, send prompts, receive newline-delimited JSON events, and resume conversations.

Purpose: Codex is the OpenAI backend option. This adapter translates Backend.Send() calls into `codex` CLI invocations and parses the event-stream JSON output to extract the response text and thread ID.
Output: Working CodexAdapter with unit tests, wired into the Backend factory.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-subprocess-management-and-backend-abstraction/01-RESEARCH.md
@.planning/phases/01-subprocess-management-and-backend-abstraction/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Codex adapter</name>
  <files>internal/backend/codex.go, internal/backend/backend.go</files>
  <action>
1. Create `internal/backend/codex.go` with:

   - `CodexAdapter` struct with fields:
     - `threadID string` — thread ID for resuming conversations
     - `workDir string` — working directory for the CLI
     - `model string` — model override (optional)
     - `started bool` — tracks whether first message has been sent
     - `procMgr *ProcessManager` — reference to shared process manager

   - `NewCodexAdapter(cfg Config, procMgr *ProcessManager) (*CodexAdapter, error)`:
     - ThreadID is NOT pre-generated — it comes from the first exec response (ThreadStarted event)
     - If cfg.SessionID is provided, use it as initial threadID (for resuming existing sessions)
     - Set workDir, model from cfg
     - Return configured adapter

   - `Send(ctx context.Context, msg Message) (Response, error)`:
     - If first message (`!started` and `threadID` is empty):
       Build args: `["exec", msg.Content, "--json"]`
     - If resuming (`started` or `threadID` is set):
       Build args: `["resume", threadID, "--json"]`
       Note: For resume with new prompt, Codex may require piping stdin or a different approach. Based on research, `codex resume <THREAD_ID>` resumes interactive mode. For non-interactive resume with a new message, check if `codex exec resume <THREAD_ID> "prompt" --json` works. If not, the resume command may need to receive input via stdin.
       Simpler approach: For multi-turn, use `codex exec "prompt" --json` with the thread ID passed via environment or flag if available. If Codex CLI doesn't support passing a thread ID for exec, track the thread ID for reference but each exec may start a new thread.
       **Resolution:** Use `codex exec "prompt" --json` for first call, `codex resume <THREAD_ID> --json` for subsequent. If resume doesn't accept a prompt, pipe it via stdin. Build both `buildFirstArgs` and `buildResumeArgs` methods to test independently.
     - If `model` is set: append `"--model", model`
     - Create command via `newCommand(ctx, "codex", args...)`
     - Set `cmd.Dir = workDir`
     - Execute via `executeCommand(ctx, cmd, procMgr)`
     - Parse newline-delimited JSON from stdout (see parsing below)
     - Extract threadID from ThreadStarted event if present, store for future resume
     - Extract response content from TurnCompleted event
     - Set `started = true`
     - Return Response

   - Codex event parsing — define private types:
     ```go
     type codexEvent struct {
         Type string `json:"type"`
     }
     type codexThreadStarted struct {
         Type     string `json:"type"`
         ThreadID string `json:"thread_id"`
     }
     type codexTurnCompleted struct {
         Type    string `json:"type"`
         Content string `json:"content"`
     }
     ```
     Parse function `parseCodexEvents(data []byte) (threadID string, content string, err error)`:
     - Split by newlines
     - For each non-empty line, unmarshal into `codexEvent` to get type
     - If type is "ThreadStarted", unmarshal into `codexThreadStarted`, extract thread_id
     - If type is "TurnCompleted", unmarshal into `codexTurnCompleted`, extract content
     - Return last seen threadID and content from last TurnCompleted

   - `Close() error`: No-op (per-invocation subprocess). Return nil.

   - `SessionID() string`: Return `threadID`

   - `buildArgs(msg Message) []string`: Extract command construction into testable method.

2. Update `internal/backend/backend.go`:
   - In `New()` factory, wire up: `case "codex": return NewCodexAdapter(cfg, pm)`
  </action>
  <verify>
`go build ./...` passes. `go vet ./...` passes. CodexAdapter implements Backend interface. New("codex", ...) returns a CodexAdapter.
  </verify>
  <done>
CodexAdapter implements Backend interface. Builds correct `codex exec` command for first call and `codex resume <THREAD_ID>` for subsequent calls with --json flag. Parses newline-delimited JSON events to extract thread_id and response content. Factory function wired up.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Codex adapter unit tests</name>
  <files>internal/backend/codex_test.go</files>
  <action>
Create `internal/backend/codex_test.go` with tests:

1. `TestNewCodexAdapter_NoInitialThreadID`: Create adapter with empty SessionID. Verify SessionID() returns empty string (threadID comes from first exec response).

2. `TestNewCodexAdapter_UsesProvidedThreadID`: Create adapter with specific SessionID. Verify SessionID() returns that ID and started behavior uses resume.

3. `TestCodexAdapter_BuildsFirstExecCommand`: Test that first Send builds args with `exec`. Verify args contain: `exec`, prompt content, `--json`. Verify args do NOT contain `resume`.

4. `TestCodexAdapter_BuildsResumeCommand`: Test that after setting threadID, args use `resume <THREAD_ID>`. Verify args contain: `resume`, thread ID, `--json`.

5. `TestCodexAdapter_IncludesModel`: Test that when model is configured, `--model` appears in args.

6. `TestCodexAdapter_ParsesEventStream`: Test the event parsing logic with sample newline-delimited JSON:
   ```
   {"type":"ThreadStarted","thread_id":"thread_abc123"}
   {"type":"TurnStarted"}
   {"type":"TurnCompleted","content":"The answer is 42"}
   ```
   Verify: threadID = "thread_abc123", content = "The answer is 42"

7. `TestCodexAdapter_ParsesEmptyEvents`: Test with empty input — should return empty content, no error.

8. `TestCodexAdapter_ParsesMalformedJSON`: Test with invalid JSON line — should return error.

9. `TestCodexAdapter_ExtractsThreadIDFromResponse`: Test that after parsing a response with ThreadStarted event, the adapter stores the threadID for future calls.

10. `TestCodexAdapter_Close`: Verify Close() returns nil.
  </action>
  <verify>
`go test ./internal/backend/ -v -run TestCodex` — all tests pass.
  </verify>
  <done>
All Codex adapter unit tests pass. Command construction produces correct exec vs resume commands. Event stream parser handles ThreadStarted and TurnCompleted events. Thread ID is captured from first response.
  </done>
</task>

</tasks>

<verification>
- `go test ./internal/backend/ -v -run TestCodex` — all tests pass
- `go build ./...` — compiles cleanly
- CodexAdapter satisfies Backend interface (compile-time check)
- Event parser extracts thread_id from ThreadStarted and content from TurnCompleted
- buildArgs produces correct command structure for exec vs resume
</verification>

<success_criteria>
Codex adapter fully implements Backend interface. Unit tests verify command construction (exec vs resume, --json, --model) and newline-delimited JSON event parsing. Factory function creates CodexAdapter for type "codex".
</success_criteria>

<output>
After completion, create `.planning/phases/01-subprocess-management-and-backend-abstraction/01-03-SUMMARY.md`
</output>
