---
phase: 03-parallel-execution-with-git-isolation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/worktree/types.go
  - internal/worktree/manager.go
  - internal/worktree/manager_test.go
autonomous: true

must_haves:
  truths:
    - "A worktree can be created for a task, producing an isolated directory with a unique branch"
    - "A completed worktree branch can be merged back to the base branch"
    - "Worktrees and their branches are cleaned up on both success and failure paths"
    - "Stale worktrees from previous runs are pruned on startup"
    - "Merge conflicts are detected and reported without corrupting git state"
  artifacts:
    - path: "internal/worktree/types.go"
      provides: "WorktreeInfo, MergeStrategy, MergeResult types"
      exports: ["WorktreeInfo", "MergeStrategy", "MergeResult", "MergeOrt", "MergeOurs", "MergeTheirs"]
    - path: "internal/worktree/manager.go"
      provides: "WorktreeManager with Create, Merge, Cleanup, List, Prune"
      exports: ["WorktreeManager", "NewWorktreeManager", "WorktreeManagerConfig"]
    - path: "internal/worktree/manager_test.go"
      provides: "Tests for all worktree lifecycle operations"
  key_links:
    - from: "internal/worktree/manager.go"
      to: "git CLI"
      via: "os/exec commands"
      pattern: "exec\\.Command.*git.*worktree"
---

<objective>
Git worktree lifecycle manager: create isolated worktrees per task, merge results back, clean up on success/failure, and prune stale worktrees.

Purpose: EXEC-02 (isolated git worktrees) and EXEC-03 (merge-back with configurable strategy) require a self-contained worktree manager that handles the full lifecycle. This is the foundation that the parallel runner (Plan 03) will use.
Output: internal/worktree/ package with WorktreeManager, types, and tests.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-parallel-execution-with-git-isolation/03-RESEARCH.md
@internal/scheduler/task.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Worktree types and manager with create/cleanup operations</name>
  <files>internal/worktree/types.go, internal/worktree/manager.go</files>
  <action>
Create `internal/worktree/types.go`:
- `MergeStrategy` type (int) with constants: `MergeOrt`, `MergeOurs`, `MergeTheirs`. Add `String()` method returning "ort", "ours", "theirs".
- `WorktreeInfo` struct: `Path string`, `Branch string`, `TaskID string`, `Head string`.
- `MergeResult` struct: `Merged bool`, `ConflictFiles []string`, `Error error`.
- `WorktreeManagerConfig` struct: `RepoPath string`, `BaseBranch string`, `WorktreeDir string` (directory under repo for worktrees, default ".worktrees"), `DefaultStrategy MergeStrategy`.

Create `internal/worktree/manager.go`:
- `WorktreeManager` struct holding `config WorktreeManagerConfig`.
- `NewWorktreeManager(cfg WorktreeManagerConfig) *WorktreeManager`.
- `Create(taskID string) (*WorktreeInfo, error)`:
  - Branch name: `task/{taskID}`
  - Worktree path: `filepath.Join(config.RepoPath, config.WorktreeDir, taskID)`
  - Run `git worktree add -b task/{taskID} {path} {baseBranch}` with `cmd.Dir = config.RepoPath`
  - Return populated WorktreeInfo.
- `Merge(info *WorktreeInfo, strategy MergeStrategy) (*MergeResult, error)`:
  - First detect conflicts with `git merge-tree --write-tree {baseBranch} {info.Branch}` -- if non-zero exit, return MergeResult with `Merged: false` and parse conflict info.
  - If clean, run `git merge --no-ff -s {strategy} {info.Branch}` with `cmd.Dir = config.RepoPath`. The `--no-ff` creates a merge commit for traceability.
  - Return MergeResult with `Merged: true`.
- `Cleanup(info *WorktreeInfo) error`:
  - Run `git worktree remove {info.Path}`. If fails, retry with `--force`.
  - Run `git branch -d {info.Branch}`. If fails (unmerged), use `-D`.
  - Errors are collected but not fatal -- best-effort cleanup.
- `ForceCleanup(info *WorktreeInfo) error`:
  - Same as Cleanup but always uses `--force` and `-D` flags directly. Used in defer/shutdown paths.
- `List() ([]WorktreeInfo, error)`:
  - Run `git worktree list --porcelain`, parse output with bufio.Scanner per research pattern.
- `Prune() error`:
  - Run `git worktree prune` to clean stale metadata from previous crashes.

All git commands use `exec.Command` with `cmd.Dir = config.RepoPath`. Capture `CombinedOutput()` for error messages. Wrap errors with `fmt.Errorf` including command output for debuggability.
  </action>
  <verify>
`go build ./internal/worktree/...` compiles without errors.
`go vet ./internal/worktree/...` reports no issues.
  </verify>
  <done>WorktreeManager has Create, Merge, Cleanup, ForceCleanup, List, Prune methods. Types define MergeStrategy, WorktreeInfo, MergeResult.</done>
</task>

<task type="auto">
  <name>Task 2: Worktree manager tests with real git operations</name>
  <files>internal/worktree/manager_test.go</files>
  <action>
Create `internal/worktree/manager_test.go` with tests that use real git repos in `t.TempDir()`.

Helper function `setupTestRepo(t *testing.T) string`:
- Create temp dir, `git init`, `git checkout -b main`, create a file, `git add .`, `git commit -m "initial"`.
- Return repo path.

Tests:
1. `TestCreate` -- Create worktree for a task. Verify: worktree directory exists, contains `.git` file (not dir -- worktrees use gitfile), branch exists in `git branch` output, returned WorktreeInfo has correct Path/Branch/TaskID.

2. `TestCreateDuplicateID` -- Create two worktrees with same task ID. Second should fail (branch already exists).

3. `TestMergeClean` -- Create worktree, add a new file inside it (`git add` + `git commit` in worktree dir), merge back. Verify: new file exists in main worktree after merge, MergeResult.Merged is true.

4. `TestMergeConflict` -- Create worktree, modify same file in both main and worktree with different content, commit both. Attempt merge. Verify: MergeResult.Merged is false, ConflictFiles is non-empty or Error is non-nil. After failed merge detection, git state is still clean (no merge in progress).

5. `TestCleanup` -- Create worktree, clean it up. Verify: worktree directory removed, branch deleted, `git worktree list` no longer includes it.

6. `TestForceCleanup` -- Create worktree, make uncommitted changes in it, force cleanup. Verify: directory and branch removed despite dirty state.

7. `TestPrune` -- Create worktree, manually remove its directory (`os.RemoveAll`), then call Prune. Verify: no error, `git worktree list` no longer shows stale entry.

8. `TestList` -- Create two worktrees. Call List. Verify: returned slice contains both plus the main worktree (3 total), each with correct Branch and Path.

Run all tests with `-race` flag. Each test uses `t.TempDir()` for isolation.
  </action>
  <verify>
`go test -race -v ./internal/worktree/...` -- all tests pass.
  </verify>
  <done>8 tests covering create, duplicate prevention, clean merge, conflict detection, cleanup, force cleanup, prune, and list. All pass under -race.</done>
</task>

</tasks>

<verification>
- `go build ./internal/worktree/...` compiles
- `go vet ./internal/worktree/...` is clean
- `go test -race -v ./internal/worktree/...` all pass
- Existing tests still pass: `go test -race ./internal/...`
</verification>

<success_criteria>
- WorktreeManager creates isolated worktrees with unique branches per task ID
- Clean merges succeed and bring changes to base branch
- Merge conflicts are detected without corrupting repository state
- Cleanup removes both worktree directory and branch
- Prune handles stale worktree metadata from crashed runs
- All 8+ tests pass under -race
</success_criteria>

<output>
After completion, create `.planning/phases/03-parallel-execution-with-git-isolation/03-01-SUMMARY.md`
</output>
