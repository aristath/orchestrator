---
phase: 03-parallel-execution-with-git-isolation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/orchestrator/qa_channel.go
  - internal/orchestrator/qa_channel_test.go
autonomous: true

must_haves:
  truths:
    - "A satellite agent can send a question to the orchestrator without blocking"
    - "The orchestrator receives and answers questions using its plan context"
    - "Other agents continue executing while one agent waits for an answer"
    - "Questions and answers are routed correctly (no cross-talk between agents)"
    - "Channel respects context cancellation for clean shutdown"
  artifacts:
    - path: "internal/orchestrator/qa_channel.go"
      provides: "QAChannel with Ask, Start, Stop, and question/answer types"
      exports: ["QAChannel", "NewQAChannel", "Question", "Answer", "AnswerFunc"]
    - path: "internal/orchestrator/qa_channel_test.go"
      provides: "Tests for Q&A channel concurrency, routing, cancellation"
  key_links:
    - from: "internal/orchestrator/qa_channel.go"
      to: "context.Context"
      via: "select with ctx.Done()"
      pattern: "select.*case.*ctx\\.Done"
---

<objective>
Non-blocking Q&A communication channel allowing satellite agents to ask the orchestrator clarifying questions without blocking other running agents.

Purpose: EXEC-04 requires satellite agents to ask the orchestrator questions using its full plan context. This channel must be non-blocking -- one agent waiting for an answer must not stall others. Built as an independent package that the parallel runner (Plan 03) wires in.
Output: internal/orchestrator/ package with QAChannel, types, and tests.
</objective>

<execution_context>
@/Users/aristath/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aristath/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-parallel-execution-with-git-isolation/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: QAChannel types and implementation</name>
  <files>internal/orchestrator/qa_channel.go</files>
  <action>
Create `internal/orchestrator/qa_channel.go`:

Types:
- `Question` struct: `TaskID string`, `Content string`, `responseCh chan Answer` (unexported -- internal routing).
- `Answer` struct: `Content string`, `Error error`.
- `AnswerFunc` type: `func(ctx context.Context, taskID string, question string) (string, error)` -- callback the orchestrator provides for answering questions using plan context.

`QAChannel` struct:
- `questionCh chan Question` (buffered)
- `answerFn AnswerFunc`
- `done chan struct{}` (signals handler goroutine is finished)

`NewQAChannel(bufferSize int, answerFn AnswerFunc) *QAChannel`:
- Create buffered question channel with `bufferSize` capacity.
- Store the answer function.
- Initialize done channel.

`Start(ctx context.Context)`:
- Launch `go handleQuestions(ctx)` goroutine.
- The handler loops: select on `ctx.Done()` (return) or `questionCh` (process question).
- For each question: call `answerFn(ctx, q.TaskID, q.Content)`, send Answer back on `q.responseCh`. If ctx is cancelled during answer, send Answer with ctx.Err().
- On exit (ctx.Done), close `done` channel.

`Ask(ctx context.Context, taskID string, question string) (string, error)`:
- Create `responseCh := make(chan Answer, 1)` (buffered to prevent handler blocking).
- Build Question with taskID, content, responseCh.
- Select: send question on `questionCh`, or `ctx.Done()` returns ctx.Err().
- Select: receive answer from `responseCh`, or `ctx.Done()` returns ctx.Err().
- Return answer content and error.

`Stop()`:
- Blocks until `done` channel is closed (handler goroutine exited).

Design notes:
- Buffer size should be 2x concurrency limit (per research recommendation). Caller configures via `bufferSize` param.
- Per-question response channel ensures correct routing -- no need for response map/mutex.
- Double select in Ask prevents goroutine leak on cancellation.
  </action>
  <verify>
`go build ./internal/orchestrator/...` compiles without errors.
`go vet ./internal/orchestrator/...` reports no issues.
  </verify>
  <done>QAChannel with Ask/Start/Stop methods, Question/Answer/AnswerFunc types, buffered channel with per-question response routing.</done>
</task>

<task type="auto">
  <name>Task 2: QAChannel tests for concurrency and cancellation</name>
  <files>internal/orchestrator/qa_channel_test.go</files>
  <action>
Create `internal/orchestrator/qa_channel_test.go`:

Mock answer function for tests: `func mockAnswer(ctx context.Context, taskID, question string) (string, error)` that returns `fmt.Sprintf("answer for %s: %s", taskID, question)`.

Tests:
1. `TestAskAndReceive` -- Start channel, ask a question, verify correct answer returned. Simple happy path.

2. `TestMultipleConcurrentAskers` -- Start channel, launch 4 goroutines each asking a question with different taskIDs simultaneously. Use sync.WaitGroup to coordinate. Verify: all 4 get correct answers (taskID in answer matches), no deadlocks, no cross-talk.

3. `TestContextCancellation_AskBlocked` -- Start channel with buffer size 1. Fill the buffer by sending a question without consuming it. Cancel context. Verify: Ask returns ctx.Err() promptly (within 100ms).

4. `TestContextCancellation_StopsHandler` -- Start channel, cancel context. Call Stop(). Verify: Stop returns promptly (handler exited). No goroutine leak.

5. `TestSlowAnswer_DoesNotBlockOthers` -- Use an answer function that sleeps 200ms for taskID "slow" and returns immediately for others. Launch "slow" ask and "fast" ask concurrently. Verify: "fast" answer arrives before "slow" answer. This proves non-blocking for other agents but note that with a single handler goroutine processing questions serially, "fast" will arrive after "slow" if "slow" was queued first. The test should verify that the channel accepts both questions without blocking the callers' goroutines (both sends succeed quickly), even if answers are sequential. If truly parallel answering is needed later, the handler can be changed to spawn goroutines per question.

6. `TestAnswerError` -- AnswerFunc returns an error. Verify: Ask returns the error correctly.

7. `TestAskAfterStop` -- Cancel context, wait for Stop. Attempting Ask on cancelled context should return error.

All tests use `-race` flag. Use short timeouts (1-2 seconds) in tests to prevent hanging.
  </action>
  <verify>
`go test -race -v ./internal/orchestrator/...` -- all tests pass.
  </verify>
  <done>7 tests covering single ask, concurrent asks, cancellation at send/receive, stop behavior, error propagation, and post-stop behavior. All pass under -race.</done>
</task>

</tasks>

<verification>
- `go build ./internal/orchestrator/...` compiles
- `go vet ./internal/orchestrator/...` is clean
- `go test -race -v ./internal/orchestrator/...` all pass
- Existing tests still pass: `go test -race ./internal/...`
</verification>

<success_criteria>
- Satellite agents can ask questions via Ask() and receive answers
- Multiple concurrent askers do not block each other at the send level
- Context cancellation stops the handler and unblocks pending asks
- Answer routing is correct (no cross-talk between task IDs)
- All 7 tests pass under -race
</success_criteria>

<output>
After completion, create `.planning/phases/03-parallel-execution-with-git-isolation/03-02-SUMMARY.md`
</output>
